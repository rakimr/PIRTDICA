{% extends "base.html" %}

{% block title %}Chart Gallery - PIRTDICA{% endblock %}

{% block content %}
<div class="trends-page">
    <div class="trends-header">
        <div>
            <h1 class="page-title">CHART GALLERY</h1>
            <p class="page-subtitle">Data-driven analysis for today's slate</p>
        </div>
        <form action="/trends/refresh" method="post" class="refresh-form">
            <button type="submit" class="btn btn-secondary refresh-btn">
                Refresh Data
            </button>
        </form>
    </div>
    
    <div class="trends-section">
        <h2>Usage to Fantasy Points</h2>
        <p class="chart-description">Usage rate vs fantasy points. Bigger bubbles = better value (FP per $1K). Top-right = high-usage stars.</p>
        <div class="chart-container">
            <img src="/static/images/value_chart.png?v={{ cache_bust }}" alt="Usage to Fantasy Points" class="trend-chart">
        </div>
    </div>
    
    <div class="trends-section">
        <h2>Risk-Reward Frontier</h2>
        <p class="chart-description">Bottom-right = cash plays, top-left = GPP darts, top-right = slate breakers.</p>
        <div class="chart-container">
            <img src="/static/images/upside_chart.png?v={{ cache_bust }}" alt="Risk-Reward Frontier" class="trend-chart">
        </div>
    </div>
    
    <div class="trends-section">
        <h2>Referee Foul Tendencies</h2>
        <p class="chart-description">Tonight's crews plotted by foul volume (X) and home/away bias (Y). ▲ = home-favored, ▼ = road-favored.</p>
        <div class="chart-container">
            {% if ref_chart_exists %}
            <img src="/static/images/ref_foul_chart.png?v={{ cache_bust }}" alt="Referee Foul Chart" class="trend-chart">
            {% else %}
            <div style="text-align:center; padding:40px 20px; color:#888; font-size:1.1rem;">
                Referee assignments for tonight's games haven't been posted yet. Check back closer to tip-off.
            </div>
            {% endif %}
        </div>
    </div>
    
    <div class="trends-section">
        <h2>Defense vs Position Matchups</h2>
        <p class="chart-description">Green = soft matchup (target). Red = tough matchup (avoid).</p>
        <div class="chart-container">
            <img src="/static/images/dvp_heatmap.png?v={{ cache_bust }}" alt="DVP Heatmap" class="trend-chart dvp-heatmap">
        </div>
    </div>

    <div class="trends-section">
        <h2>Defense vs Archetype (DVA)</h2>
        <p class="chart-description">How teams defend playstyles, not positions. DVS multiplier combines archetype stat profile with defensive leaks. Toggle between FP/min differential and DVS multiplier. Hover cells for stat breakdown.</p>
        <div class="dva-controls">
            <button class="dva-mode-btn active" data-mode="dvs">DVS Multiplier</button>
            <button class="dva-mode-btn" data-mode="fp">FP/min Diff</button>
        </div>
        <div class="dva-table-wrapper">
            <div id="dva-loading" style="text-align:center; padding:40px; color:#888;">Loading DVA data...</div>
            <div id="dva-table-container" style="display:none; overflow-x:auto;"></div>
        </div>
    </div>

    <div class="trends-section">
        <h2>Team Offensive Scheme Profile</h2>
        <p class="chart-description">How teams distribute their possessions across play types. Radar shows scheme shape vs league average. Select a team to explore its offensive identity.</p>
        <div class="scheme-controls">
            <select id="scheme-team-select" class="scheme-select">
                <option value="">Loading teams...</option>
            </select>
            <div class="scheme-toggle">
                <button class="scheme-mode-btn active" data-mode="poss">Possession %</button>
                <button class="scheme-mode-btn" data-mode="ppp">Efficiency (PPP)</button>
            </div>
        </div>
        <div class="scheme-chart-row">
            <div class="scheme-radar-wrap">
                <canvas id="scheme-radar-chart"></canvas>
            </div>
            <div class="scheme-bar-wrap">
                <canvas id="scheme-bar-chart"></canvas>
            </div>
        </div>
        <div class="scheme-bar-legend">
            <span class="sbl-item"><span class="sbl-dot" style="background:#0f9d58"></span> Elite (75th+)</span>
            <span class="sbl-item"><span class="sbl-dot" style="background:#1e3a8a"></span> Above Avg (50th+)</span>
            <span class="sbl-item"><span class="sbl-dot" style="background:#d4af37"></span> Below Avg (25th+)</span>
            <span class="sbl-item"><span class="sbl-dot" style="background:#d72638"></span> Poor (Below 25th)</span>
        </div>
        <div id="scheme-summary" class="scheme-summary"></div>
    </div>

    <div class="trends-section">
        <h2>Defensive Scheme Vulnerabilities</h2>
        <p class="chart-description">How teams defend each play type. Green = they shut it down (low PPP allowed). Red = they bleed points. Use this to target opponents' weaknesses.</p>
        <div class="scheme-controls">
            <select id="def-scheme-team-select" class="scheme-select">
                <option value="">Loading teams...</option>
            </select>
        </div>
        <div class="def-scheme-chart-wrap">
            <canvas id="def-scheme-chart"></canvas>
        </div>
        <div class="scheme-bar-legend">
            <span class="sbl-item"><span class="sbl-dot" style="background:rgba(215,38,56,0.75)"></span> Weakness (allows more PPP than avg)</span>
            <span class="sbl-item"><span class="sbl-dot" style="background:rgba(15,157,88,0.75)"></span> Strength (allows less PPP than avg)</span>
            <span class="sbl-item"><span class="sbl-dot" style="background:rgba(107,114,128,0.5)"></span> Neutral</span>
            <span class="sbl-item"><span class="sbl-dot sbl-line" style="background:#9ca3af"></span> League Avg Line</span>
        </div>
        <div id="def-scheme-summary" class="def-scheme-summary"></div>
    </div>

    <div class="trends-section">
        <h2>Player Archetype Clusters</h2>
        <p class="chart-description">K-Means clustering groups players by how they actually play. Each dot is a player, positioned by PCA of 12 statistical features. Hover for details.</p>
        <div class="cluster-chart-wrapper">
            <canvas id="cluster-chart"></canvas>
        </div>
        <div id="cluster-legend" class="cluster-legend"></div>
    </div>
    
    {% if top_value %}
    <div class="trends-section">
        <h2>Top Value Plays</h2>
        <p class="chart-description">Players outperforming their salary tier. Value vs Tier shows how much better than peers at similar price.</p>
        <div class="value-table">
            <table>
                <thead>
                    <tr>
                        <th data-sortable="string">Player</th>
                        <th data-sortable="string">Team</th>
                        <th data-sortable="number">Salary</th>
                        <th data-sortable="number">Proj FP</th>
                        <th data-sortable="number">Floor</th>
                        <th data-sortable="number">Ceiling</th>
                        <th data-sortable="number">FP/$1k</th>
                        <th data-sortable="number">vs Tier</th>
                        <th data-sortable="string">Tier</th>
                        <th data-sortable="string">Archetype</th>
                    </tr>
                </thead>
                <tbody>
                    {% for player in top_value %}
                    <tr>
                        <td>{{ player.player_name }}</td>
                        <td>{{ player.team }}</td>
                        <td>${{ "{:,}".format(player.salary|int) }}</td>
                        <td>{{ "%.1f"|format(player.proj_fp) }}</td>
                        <td>{{ "%.1f"|format(player.get('floor', 0)) }}</td>
                        <td>{{ "%.1f"|format(player.get('ceiling', 0)) }}</td>
                        <td class="value-cell">{{ "%.2f"|format(player.get('value_ratio', player.get('value', 0))) }}</td>
                        <td class="{% if player.get('value_vs_tier', 0) > 0 %}positive-value{% else %}negative-value{% endif %}">{{ "%+.1f"|format((player.get('value_vs_tier', 0) * 100)) }}%</td>
                        <td>{{ player.get('tier', player.get('salary_tier', '')) }}</td>
                        <td><span class="archetype-badge archetype-{{ player.get('archetype', 'Unknown')|lower|replace(' ', '-')|replace('(', '')|replace(')', '') }}">{{ player.get('archetype', '') }}</span></td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    {% endif %}
    
    {% if targeted %}
    <div class="trends-section">
        <h2>Targeted Stat Plays</h2>
        <p class="chart-description">Players facing teams that give up extra fantasy points in specific stats. Sorted by FP impact.</p>
        <div class="targeted-table">
            <table>
                <thead>
                    <tr>
                        <th>Player</th>
                        <th>Pos</th>
                        <th>vs</th>
                        <th>Stat</th>
                        <th>Avg</th>
                        <th>+FP</th>
                        <th>Matchup Note</th>
                    </tr>
                </thead>
                <tbody>
                    {% for play in targeted %}
                    <tr>
                        <td>{{ play.player_name }}</td>
                        <td>{{ play.position }}</td>
                        <td>{{ play.opponent }}</td>
                        <td>{{ play.stat }}</td>
                        <td>{{ play.player_avg }}</td>
                        <td class="edge-cell">+{{ play.extra_fp }}</td>
                        <td class="matchup-note">{{ play.recommendation }}</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    {% endif %}
    
    {% if props %}
    <div class="trends-section">
        <h2>Prop Recommendations</h2>
        <p class="chart-description">Our projections vs FanDuel book lines. Sorted by largest edge where our model disagrees with the market.</p>
        <div class="table-controls">
            <input type="text" class="table-search" data-table="props-table" placeholder="Search player...">
        </div>
        <div class="props-table">
            <table id="props-table">
                <thead>
                    <tr>
                        <th data-sortable="text">Player</th>
                        <th data-sortable="text">vs</th>
                        <th data-sortable="text">Stat</th>
                        <th data-sortable="number">Avg</th>
                        <th data-sortable="number">Proj</th>
                        <th data-sortable="number">Line</th>
                        <th data-sortable="number">Edge%</th>
                        <th data-sortable="text">Call</th>
                        <th>Trend</th>
                    </tr>
                </thead>
                <tbody>
                    {% for prop in props %}
                    <tr>
                        <td>{{ prop.player }}</td>
                        <td>{{ prop.opponent }}</td>
                        <td>{{ prop.stat }}</td>
                        <td>{{ prop.player_avg }}</td>
                        <td>{{ prop.adjusted_avg }}</td>
                        <td>{{ prop.book_line if prop.book_line is not none and prop.book_line == prop.book_line else '—' }}</td>
                        <td class="{% if prop.vs_book_edge is not none and prop.vs_book_edge == prop.vs_book_edge %}{% if prop.vs_book_edge > 15 %}fp-positive{% elif prop.vs_book_edge < -15 %}fp-negative{% else %}fp-neutral{% endif %}{% endif %}">{{ '%+.1f'|format(prop.vs_book_edge) if prop.vs_book_edge is not none and prop.vs_book_edge == prop.vs_book_edge else '—' }}</td>
                        <td class="{% if prop.recommendation == 'OVER' %}over-cell{% else %}under-cell{% endif %}">{{ prop.recommendation }}</td>
                        <td class="trend-btn-cell"><button class="trend-analysis-btn" data-player="{{ prop.player }}" data-stat="{{ prop.stat }}" data-line="{{ prop.book_line if prop.book_line is not none and prop.book_line == prop.book_line else '' }}" data-call="{{ prop.recommendation }}" title="View trend">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                        </button></td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    {% endif %}
</div>

<div id="trend-modal" class="trend-modal-overlay" style="display:none;">
    <div class="trend-modal">
        <div class="trend-modal-header">
            <h3 id="trend-modal-title"></h3>
            <button class="trend-modal-close" onclick="closeTrendModal()">&times;</button>
        </div>
        <div class="trend-modal-body">
            <canvas id="trend-chart" height="260"></canvas>
        </div>
        <div class="trend-modal-legend">
            <span class="legend-item"><span class="legend-line legend-blue"></span> FanDuel Line</span>
            <span class="legend-item"><span class="legend-line legend-grey"></span> Player Average</span>
        </div>
        <div class="trend-modal-footer">
            <span id="trend-modal-avg"></span>
            <span id="trend-modal-call"></span>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
const ARCHETYPE_COLORS = {
    'Playmaker': '#00E5FF',
    'Combo Guard': '#FF6D00',
    '3-and-D Wing': '#39FF14',
    'Scoring Wing': '#FF1744',
    'Stretch 4': '#D4AF37',
    'Stretch 5': '#AA00FF',
    'Traditional Big': '#607D8B',
    'Versatile Big': '#FF4081',
    'Point Center': '#00BFA5',
    'Point Forward': '#FFEA00',
};

let dvaMode = 'dvs';
let dvaData = null;

async function loadDVA() {
    try {
        const res = await fetch('/api/dva');
        dvaData = await res.json();
        if (dvaData.error || !dvaData.teams || dvaData.teams.length === 0) {
            document.getElementById('dva-loading').textContent = dvaData.error || 'No DVA data available.';
            return;
        }
        renderDVA();
    } catch(e) {
        document.getElementById('dva-loading').textContent = 'Failed to load DVA data.';
    }
}

function dvaColor(val, mode) {
    const maxVal = mode === 'dvs' ? 20 : 0.15;
    const t = Math.max(-1, Math.min(1, val / maxVal));
    const norm = (t + 1) / 2;
    let r, g, b;
    if (norm >= 0.5) {
        const p = (norm - 0.5) * 2;
        r = Math.round(255 * (1 - p) + 26 * p);
        g = Math.round(255 * (1 - p) + 150 * p);
        b = Math.round(191 * (1 - p * 0.8) + 65 * p);
    } else {
        const p = norm * 2;
        r = Math.round(215 * (1 - p) + 255 * p);
        g = Math.round(48 * (1 - p) + 255 * p);
        b = Math.round(39 * (1 - p) + 191 * p);
    }
    return `rgb(${r},${g},${b})`;
}

function dvaTextColor(val, mode) {
    const maxVal = mode === 'dvs' ? 20 : 0.15;
    const t = Math.abs(val / maxVal);
    return t > 0.7 ? '#fff' : '#222';
}

function buildTooltip(cell, team, arch) {
    const d = dvaData.data[team][arch];
    const statNames = {pts:'PTS', reb:'REB', ast:'AST', stl:'STL', blk:'BLK', fg3m:'3PM', tov:'TOV'};
    let html = '<div class="dva-tooltip">';
    html += '<div class="dva-tooltip-title">' + team + ' vs ' + arch + '</div>';
    html += '<div class="dva-tooltip-row"><span>FP/min diff:</span><span>' + (d.fp_pm_diff >= 0 ? '+' : '') + d.fp_pm_diff.toFixed(4) + '</span></div>';
    html += '<div class="dva-tooltip-row"><span>DVS Multiplier:</span><span>' + (d.dvs_multiplier >= 0 ? '+' : '') + d.dvs_multiplier.toFixed(2) + '%</span></div>';
    html += '<div class="dva-tooltip-row"><span>Sample:</span><span>' + d.sample_n + ' games</span></div>';
    html += '<div class="dva-tooltip-divider"></div>';
    html += '<div class="dva-tooltip-subtitle">Stat Leak (per min vs avg)</div>';
    for (const [k, label] of Object.entries(statNames)) {
        const v = d.stat_diffs[k];
        const cls = v > 0.001 ? 'dva-pos' : v < -0.001 ? 'dva-neg' : '';
        html += '<div class="dva-tooltip-row ' + cls + '"><span>' + label + ':</span><span>' + (v >= 0 ? '+' : '') + v.toFixed(4) + '</span></div>';
    }
    if (d.dvs_components) {
        html += '<div class="dva-tooltip-divider"></div>';
        html += '<div class="dva-tooltip-subtitle">DVS Components</div>';
        for (const [k, label] of Object.entries(statNames)) {
            const v = d.dvs_components[k];
            if (Math.abs(v) >= 0.01) {
                const cls = v > 0 ? 'dva-pos' : 'dva-neg';
                html += '<div class="dva-tooltip-row ' + cls + '"><span>' + label + ':</span><span>' + (v >= 0 ? '+' : '') + v.toFixed(2) + '%</span></div>';
            }
        }
    }
    html += '</div>';
    return html;
}

function renderDVA() {
    if (!dvaData || !dvaData.teams) return;
    const container = document.getElementById('dva-table-container');
    const isMobile = window.innerWidth < 768;
    const shortNames = {
        'Playmaker': 'PM', 'Combo Guard': 'CG',
        '3-and-D Wing': '3&D', 'Scoring Wing': 'SC W',
        'Stretch 4': 'S4', 'Stretch 5': 'S5',
        'Traditional Big': 'Trd B', 'Versatile Big': 'Vrs B',
        'Point Center': 'PC', 'Point Forward': 'PF'
    };

    let html = '<table class="dva-table"><thead><tr><th class="dva-team-col">Team</th>';
    dvaData.archetypes.forEach(a => {
        const label = isMobile ? (shortNames[a] || a.substring(0,4)) : a;
        html += '<th class="dva-arch-col">' + label + '</th>';
    });
    html += '</tr></thead><tbody>';

    dvaData.teams.forEach(team => {
        html += '<tr><td class="dva-team-cell">' + team + '</td>';
        dvaData.archetypes.forEach(arch => {
            const d = dvaData.data[team] && dvaData.data[team][arch];
            if (!d) { html += '<td class="dva-cell">-</td>'; return; }
            const val = dvaMode === 'dvs' ? d.dvs_multiplier : d.fp_pm_diff;
            const bg = dvaColor(val, dvaMode);
            const tc = dvaTextColor(val, dvaMode);
            const display = dvaMode === 'dvs' ? (val >= 0 ? '+' : '') + val.toFixed(1) + '%' : (val >= 0 ? '+' : '') + val.toFixed(3);
            html += '<td class="dva-cell" style="background:' + bg + ';color:' + tc + '" data-team="' + team + '" data-arch="' + arch + '">' + display + '</td>';
        });
        html += '</tr>';
    });
    html += '</tbody></table>';
    container.innerHTML = html;
    container.style.display = 'block';
    document.getElementById('dva-loading').style.display = 'none';

    container.querySelectorAll('.dva-cell[data-team]').forEach(cell => {
        let tooltipEl = null;
        cell.addEventListener('mouseenter', function(e) {
            const team = this.dataset.team;
            const arch = this.dataset.arch;
            if (!dvaData.data[team] || !dvaData.data[team][arch]) return;
            tooltipEl = document.createElement('div');
            tooltipEl.className = 'dva-tooltip-wrap';
            tooltipEl.innerHTML = buildTooltip(this, team, arch);
            document.body.appendChild(tooltipEl);
            const rect = this.getBoundingClientRect();
            tooltipEl.style.left = Math.min(rect.left, window.innerWidth - 260) + 'px';
            tooltipEl.style.top = (rect.bottom + 6 + window.scrollY) + 'px';
        });
        cell.addEventListener('mouseleave', function() {
            if (tooltipEl) { tooltipEl.remove(); tooltipEl = null; }
        });
    });
}

document.querySelectorAll('.dva-mode-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.dva-mode-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        dvaMode = this.dataset.mode;
        renderDVA();
    });
});

loadDVA();

let clusterChart = null;

async function loadClusterChart() {
    try {
        const res = await fetch('/api/archetype-clusters');
        const data = await res.json();
        if (!data.players || data.players.length === 0) {
            document.querySelector('.cluster-chart-wrapper').innerHTML = '<div style="text-align:center;padding:40px 20px;color:#888;font-size:1.1rem;">Archetype clustering data not yet available. Run the daily update to generate clusters.</div>';
            return;
        }

        const grouped = {};
        data.players.forEach(p => {
            if (!grouped[p.archetype]) grouped[p.archetype] = [];
            grouped[p.archetype].push(p);
        });

        const isMobile = window.innerWidth < 768;
        const ptRadius = isMobile ? 3.5 : 6;
        const ptHover = isMobile ? 6 : 9;
        const borderW = isMobile ? 1 : 1.5;

        const datasets = Object.entries(grouped).map(([arch, players]) => ({
            label: arch,
            data: players.map(p => ({ x: p.x, y: p.y, name: p.name, team: p.team, pts: p.pts, reb: p.reb, ast: p.ast, usg: p.usg })),
            backgroundColor: (ARCHETYPE_COLORS[arch] || '#888') + 'cc',
            borderColor: ARCHETYPE_COLORS[arch] || '#888',
            borderWidth: borderW,
            pointRadius: ptRadius,
            pointHoverRadius: ptHover,
        }));

        const ctx = document.getElementById('cluster-chart').getContext('2d');
        if (clusterChart) clusterChart.destroy();

        clusterChart = new Chart(ctx, {
            type: 'scatter',
            data: { datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: isMobile ? { top: 4, right: 4, bottom: 4, left: 4 } : { top: 10, right: 10, bottom: 10, left: 10 }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const p = context.raw;
                                return [
                                    p.name + ' (' + p.team + ')',
                                    context.dataset.label,
                                    'PTS/100: ' + p.pts + '  REB/100: ' + p.reb,
                                    'AST/100: ' + p.ast + '  USG%: ' + p.usg
                                ];
                            }
                        },
                        backgroundColor: '#111',
                        titleFont: { family: 'Marvel', size: isMobile ? 11 : 13 },
                        bodyFont: { family: 'Marvel', size: isMobile ? 10 : 12 },
                        padding: isMobile ? 6 : 10,
                        cornerRadius: 6,
                    }
                },
                scales: {
                    x: {
                        title: { display: !isMobile, text: 'PC1 (' + data.variance_explained[0] + '% var)', font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' },
                        grid: { color: '#e5e7eb' },
                        ticks: { font: { family: 'Marvel', size: isMobile ? 9 : 12 }, maxTicksLimit: isMobile ? 5 : 10 }
                    },
                    y: {
                        title: { display: !isMobile, text: 'PC2 (' + data.variance_explained[1] + '% var)', font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' },
                        grid: { color: '#e5e7eb' },
                        ticks: { font: { family: 'Marvel', size: isMobile ? 9 : 12 }, maxTicksLimit: isMobile ? 5 : 10 }
                    }
                }
            }
        });

        const legendEl = document.getElementById('cluster-legend');
        legendEl.innerHTML = data.archetypes.map(arch => {
            const color = ARCHETYPE_COLORS[arch] || '#888';
            const count = (grouped[arch] || []).length;
            return '<span class="cluster-legend-item" data-arch="' + arch + '">' +
                   '<span class="cluster-legend-dot" style="background:' + color + '"></span>' +
                   arch + ' <span class="cluster-legend-count">(' + count + ')</span></span>';
        }).join('');

        legendEl.querySelectorAll('.cluster-legend-item').forEach(item => {
            item.addEventListener('click', function() {
                const arch = this.dataset.arch;
                const ds = clusterChart.data.datasets.find(d => d.label === arch);
                if (ds) {
                    const idx = clusterChart.data.datasets.indexOf(ds);
                    const meta = clusterChart.getDatasetMeta(idx);
                    meta.hidden = !meta.hidden;
                    this.classList.toggle('cluster-legend-dimmed');
                    clusterChart.update();
                }
            });
        });

    } catch(e) {
        console.error('Cluster chart error:', e);
    }
}

loadClusterChart();

let trendChart = null;

document.querySelectorAll('.trend-analysis-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const player = this.dataset.player;
        const stat = this.dataset.stat;
        const line = this.dataset.line ? parseFloat(this.dataset.line) : null;
        const call = this.dataset.call;
        openTrendModal(player, stat, line, call);
    });
});

async function openTrendModal(player, stat, line, call) {
    const modal = document.getElementById('trend-modal');
    const title = document.getElementById('trend-modal-title');
    const avgEl = document.getElementById('trend-modal-avg');
    const callEl = document.getElementById('trend-modal-call');
    
    title.textContent = player + ' — ' + stat + ' (Last 10 Games)';
    avgEl.textContent = 'Loading...';
    callEl.textContent = '';
    modal.style.display = 'flex';

    try {
        const res = await fetch('/api/player-trend/' + encodeURIComponent(player) + '/' + encodeURIComponent(stat) + '?n=10');
        const data = await res.json();
        if (data.error && (!data.games || data.games.length === 0)) {
            avgEl.textContent = 'No game log data available.';
            return;
        }
        const labels = data.games.map(g => {
            const m = g.matchup || '';
            const parts = m.split(' ');
            return parts[parts.length - 1] || g.date;
        });
        const values = data.games.map(g => g.value);
        const avg = data.avg;

        avgEl.textContent = '10-Game Avg: ' + avg;
        if (call) {
            callEl.textContent = call;
            callEl.className = call === 'OVER' ? 'trend-call-over' : 'trend-call-under';
        }

        const barColors = values.map(v => {
            if (line !== null) {
                return v >= line ? '#111827' : '#d1d5db';
            }
            return v >= avg ? '#111827' : '#d1d5db';
        });

        const ctx = document.getElementById('trend-chart').getContext('2d');
        if (trendChart) trendChart.destroy();

        const datasets = [{
            label: stat,
            data: values,
            backgroundColor: barColors,
            borderRadius: 4,
            barPercentage: 0.7
        }];

        trendChart = new Chart(ctx, {
            type: 'bar',
            data: { labels, datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: { beginAtZero: true, grid: { color: '#e5e7eb' }, ticks: { font: { family: 'Marvel' } }, title: { display: true, text: stat, font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' } },
                    x: { grid: { display: false }, ticks: { font: { family: 'Marvel', size: 11 } }, title: { display: true, text: 'Game', font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' } }
                }
            },
            plugins: [{
                id: 'customLines',
                afterDraw(chart) {
                    const ctx = chart.ctx;
                    const yAxis = chart.scales.y;
                    const xAxis = chart.scales.x;
                    
                    if (line !== null) {
                        const yLine = yAxis.getPixelForValue(line);
                        ctx.save();
                        ctx.strokeStyle = '#2563eb';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([6, 4]);
                        ctx.beginPath();
                        ctx.moveTo(xAxis.left, yLine);
                        ctx.lineTo(xAxis.right, yLine);
                        ctx.stroke();
                        ctx.restore();
                    }
                    
                    const yAvg = yAxis.getPixelForValue(avg);
                    ctx.save();
                    ctx.strokeStyle = '#6b7280';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(xAxis.left, yAvg);
                    ctx.lineTo(xAxis.right, yAvg);
                    ctx.stroke();
                    ctx.restore();
                }
            }]
        });
    } catch(e) {
        avgEl.textContent = 'Error loading trend data.';
    }
}

function closeTrendModal() {
    document.getElementById('trend-modal').style.display = 'none';
    if (trendChart) { trendChart.destroy(); trendChart = null; }
}

document.getElementById('trend-modal').addEventListener('click', function(e) {
    if (e.target === this) closeTrendModal();
});

let schemeData = null;
let schemeRadar = null;
let schemeBar = null;
let defSchemeChart = null;
let schemeMode = 'poss';

const SCHEME_COLORS = {
    team: { bg: 'rgba(17,24,39,0.25)', border: '#111827' },
    avg: { bg: 'rgba(107,114,128,0.12)', border: '#9ca3af' },
};

const PLAY_TYPE_ORDER = ['Isolation','Transition','PRBallHandler','PRRollman','Postup','Spotup','Handoff','Cut','OffScreen'];

async function loadSchemeData() {
    try {
        const res = await fetch('/api/team-schemes');
        schemeData = await res.json();
        if (schemeData.error || !schemeData.teams || schemeData.teams.length === 0) {
            document.getElementById('scheme-summary').textContent = schemeData.error || 'No scheme data available.';
            document.getElementById('def-scheme-summary').textContent = schemeData.error || 'No scheme data available.';
            return;
        }
        const sel = document.getElementById('scheme-team-select');
        const defSel = document.getElementById('def-scheme-team-select');
        sel.innerHTML = '';
        defSel.innerHTML = '';
        schemeData.teams.forEach(t => {
            sel.innerHTML += '<option value="' + t + '">' + t + '</option>';
            defSel.innerHTML += '<option value="' + t + '">' + t + '</option>';
        });
        sel.value = schemeData.teams.includes('OKC') ? 'OKC' : schemeData.teams[0];
        defSel.value = schemeData.teams.includes('OKC') ? 'OKC' : schemeData.teams[0];
        renderSchemeRadar(sel.value);
        renderDefScheme(defSel.value);
    } catch(e) {
        document.getElementById('scheme-summary').textContent = 'Failed to load scheme data.';
    }
}

function getPlayLabel(pt) {
    const labels = {
        'Isolation':'ISOLATION','Transition':'TRANSITION','PRBallHandler':'PnR BALL HANDLER','PRRollman':'PnR ROLL MAN',
        'Postup':'POST UP','Spotup':'SPOT UP','Handoff':'HANDOFF','Cut':'CUT','OffScreen':'OFF SCREEN'
    };
    return labels[pt] || pt;
}

function renderSchemeRadar(team) {
    if (!schemeData || !schemeData.offense[team]) return;
    const plays = schemeData.offense[team].filter(p => PLAY_TYPE_ORDER.includes(p.play_type));
    plays.sort((a,b) => PLAY_TYPE_ORDER.indexOf(a.play_type) - PLAY_TYPE_ORDER.indexOf(b.play_type));
    const labels = plays.map(p => getPlayLabel(p.play_type));
    const isEff = schemeMode === 'ppp';
    const teamVals = plays.map(p => isEff ? p.ppp : p.poss_pct);
    const avgVals = plays.map(p => {
        const avg = schemeData.league_avg[p.play_type];
        return avg ? (isEff ? avg.ppp : avg.poss_pct) : 0;
    });

    const ctx = document.getElementById('scheme-radar-chart').getContext('2d');
    if (schemeRadar) schemeRadar.destroy();
    schemeRadar = new Chart(ctx, {
        type: 'radar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: team,
                    data: teamVals,
                    backgroundColor: SCHEME_COLORS.team.bg,
                    borderColor: SCHEME_COLORS.team.border,
                    borderWidth: 2.5,
                    pointBackgroundColor: SCHEME_COLORS.team.border,
                    pointRadius: 4,
                },
                {
                    label: 'League Avg',
                    data: avgVals,
                    backgroundColor: SCHEME_COLORS.avg.bg,
                    borderColor: SCHEME_COLORS.avg.border,
                    borderWidth: 1.5,
                    borderDash: [5,3],
                    pointBackgroundColor: SCHEME_COLORS.avg.border,
                    pointRadius: 3,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom', labels: { font: { family: 'Marvel', size: 12 }, usePointStyle: true, padding: 14 } },
                tooltip: {
                    backgroundColor: '#111',
                    titleFont: { family: 'Marvel', size: 13 },
                    bodyFont: { family: 'Marvel', size: 12 },
                    callbacks: {
                        label: function(ctx) {
                            return ctx.dataset.label + ': ' + (isEff ? ctx.raw.toFixed(3) + ' PPP' : ctx.raw.toFixed(1) + '%');
                        }
                    }
                }
            },
            scales: {
                r: {
                    beginAtZero: true,
                    pointLabels: { font: { family: 'Marvel', size: 11, weight: 'bold' }, color: '#374151' },
                    ticks: { font: { family: 'Marvel', size: 9 }, backdropColor: 'transparent', stepSize: isEff ? 0.2 : 5 },
                    grid: { color: '#e5e7eb' },
                    angleLines: { color: '#e5e7eb' }
                }
            }
        }
    });

    const barPlays = [...plays].sort((a,b) => b.poss_pct - a.poss_pct).slice(0, 7);
    const barLabels = barPlays.map(p => getPlayLabel(p.play_type));
    const barPctile = barPlays.map(p => p.percentile);
    const barColors = barPctile.map(v => v >= 75 ? '#0f9d58' : v >= 50 ? '#1e3a8a' : v >= 25 ? '#d4af37' : '#d72638');

    const bCtx = document.getElementById('scheme-bar-chart').getContext('2d');
    if (schemeBar) schemeBar.destroy();
    schemeBar = new Chart(bCtx, {
        type: 'bar',
        data: {
            labels: barLabels,
            datasets: [{
                label: 'Percentile',
                data: barPctile,
                backgroundColor: barColors,
                borderRadius: 4,
                barPercentage: 0.65,
            }]
        },
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: { display: true, text: 'Efficiency Percentile by Play Type', font: { family: 'Marvel', size: 14, weight: 'bold' }, color: '#111827', padding: { bottom: 8 } },
                tooltip: {
                    backgroundColor: '#111',
                    titleFont: { family: 'Marvel', size: 13 },
                    bodyFont: { family: 'Marvel', size: 12 },
                    callbacks: {
                        label: function(ctx) {
                            const p = barPlays[ctx.dataIndex];
                            return [ctx.raw + 'th percentile', p.poss_pct + '% of poss', p.ppp.toFixed(3) + ' PPP', p.efg_pct + '% eFG'];
                        }
                    }
                }
            },
            scales: {
                x: { min: 0, max: 100, title: { display: true, text: 'League Percentile', font: { family: 'Marvel', size: 12, weight: 'bold' }, color: '#374151' }, grid: { color: '#e5e7eb' }, ticks: { font: { family: 'Marvel', size: 10 } } },
                y: { grid: { display: false }, ticks: { font: { family: 'Marvel', size: 11, weight: 'bold' }, color: '#374151' } }
            }
        }
    });

    const topPlay = plays.reduce((a,b) => a.poss_pct > b.poss_pct ? a : b);
    const bestEff = plays.reduce((a,b) => a.ppp > b.ppp ? a : b);
    document.getElementById('scheme-summary').innerHTML =
        '<div class="scheme-insight"><strong>' + team + ' Offensive Identity:</strong> ' +
        'Runs ' + getPlayLabel(topPlay.play_type) + ' most often (' + topPlay.poss_pct + '% of possessions). ' +
        'Most efficient in ' + getPlayLabel(bestEff.play_type) + ' (' + bestEff.ppp.toFixed(3) + ' PPP, ' + bestEff.percentile + 'th percentile).</div>';
}

function renderDefScheme(team) {
    if (!schemeData || !schemeData.defense[team]) return;
    const plays = schemeData.defense[team].filter(p => PLAY_TYPE_ORDER.includes(p.play_type));
    plays.sort((a,b) => PLAY_TYPE_ORDER.indexOf(a.play_type) - PLAY_TYPE_ORDER.indexOf(b.play_type));
    const labels = plays.map(p => getPlayLabel(p.play_type));
    const pppVals = plays.map(p => p.ppp);
    const avgPPP = plays.map(p => { const a = schemeData.league_avg[p.play_type]; return a ? a.ppp : 0; });
    const barColors = plays.map((p,i) => p.ppp > avgPPP[i] + 0.03 ? 'rgba(215,38,56,0.75)' : p.ppp < avgPPP[i] - 0.03 ? 'rgba(15,157,88,0.75)' : 'rgba(107,114,128,0.5)');

    const ctx = document.getElementById('def-scheme-chart').getContext('2d');
    if (defSchemeChart) defSchemeChart.destroy();
    defSchemeChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: team + ' Allows',
                    data: pppVals,
                    backgroundColor: barColors,
                    borderRadius: 4,
                    barPercentage: 0.55,
                    order: 1,
                },
                {
                    label: 'League Avg',
                    data: avgPPP,
                    type: 'line',
                    borderColor: '#9ca3af',
                    borderWidth: 2,
                    borderDash: [6,3],
                    pointBackgroundColor: '#9ca3af',
                    pointRadius: 4,
                    fill: false,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: {
                    backgroundColor: '#111',
                    titleFont: { family: 'Marvel', size: 13 },
                    bodyFont: { family: 'Marvel', size: 12 },
                    callbacks: {
                        label: function(ctx) {
                            const idx = ctx.dataIndex;
                            const p = plays[idx];
                            if (ctx.dataset.label.includes('Avg')) return 'Avg: ' + ctx.raw.toFixed(3) + ' PPP';
                            const diff = (p.ppp - avgPPP[idx]).toFixed(3);
                            const sign = diff >= 0 ? '+' : '';
                            return [p.ppp.toFixed(3) + ' PPP allowed', sign + diff + ' vs avg', p.percentile + 'th percentile', p.score_pct + '% scoring rate'];
                        }
                    }
                }
            },
            scales: {
                y: { title: { display: true, text: 'Points Per Possession Allowed', font: { family: 'Marvel', size: 12, weight: 'bold' }, color: '#374151' }, grid: { color: '#e5e7eb' }, ticks: { font: { family: 'Marvel', size: 10 } } },
                x: { grid: { display: false }, ticks: { font: { family: 'Marvel', size: 11, weight: 'bold' }, color: '#374151' } }
            }
        }
    });

    const worstDef = plays.reduce((a,b) => a.ppp > b.ppp ? a : b);
    const bestDef = plays.reduce((a,b) => a.ppp < b.ppp ? a : b);
    document.getElementById('def-scheme-summary').innerHTML =
        '<div class="scheme-insight"><strong>' + team + ' Defensive Vulnerabilities:</strong> ' +
        'Weakest vs ' + getPlayLabel(worstDef.play_type) + ' (' + worstDef.ppp.toFixed(3) + ' PPP allowed, ' + worstDef.percentile + 'th percentile). ' +
        'Strongest vs ' + getPlayLabel(bestDef.play_type) + ' (' + bestDef.ppp.toFixed(3) + ' PPP allowed).</div>';
}

document.getElementById('scheme-team-select').addEventListener('change', function() { renderSchemeRadar(this.value); });
document.getElementById('def-scheme-team-select').addEventListener('change', function() { renderDefScheme(this.value); });
document.querySelectorAll('.scheme-mode-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.scheme-mode-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        schemeMode = this.dataset.mode;
        const team = document.getElementById('scheme-team-select').value;
        if (team) renderSchemeRadar(team);
    });
});

loadSchemeData();
</script>
{% endblock %}
