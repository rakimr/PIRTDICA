{% extends "base.html" %}

{% block title %}Chart Gallery - PIRTDICA{% endblock %}

{% block content %}
<style>
.sc-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9999; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(2px); }
.sc-modal { background: #fff; border-radius: 12px; max-width: 600px; width: 95%; max-height: 90vh; overflow-y: auto; position: relative; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
.sc-close { position: absolute; top: 12px; right: 16px; background: none; border: none; font-size: 1.8rem; cursor: pointer; color: #6b7280; z-index: 10; line-height: 1; }
.sc-close:hover { color: #111; }
.sc-header { padding: 20px 24px 12px; border-bottom: 1px solid #e5e7eb; }
.sc-player-info { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
.sc-player-info h2 { margin: 0; font-size: 1.3rem; font-weight: 800; letter-spacing: -0.01em; }
.sc-archetype { font-size: 0.7rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; padding: 2px 8px; border-radius: 4px; background: #f3f4f6; color: #374151; border: 1px solid #d1d5db; }
.sc-fga-count { font-size: 0.8rem; color: #6b7280; font-weight: 600; }
.sc-legend { display: flex; gap: 16px; margin-top: 8px; flex-wrap: wrap; }
.sc-leg-item { font-size: 0.72rem; color: #6b7280; display: flex; align-items: center; gap: 4px; }
.sc-leg-dot { width: 10px; height: 10px; border-radius: 2px; display: inline-block; }
.sc-body, .esc-body { padding: 16px 24px 20px; }
.sc-canvas-wrap { display: flex; justify-content: center; }
#esc-canvas { max-width: 100%; height: auto; }
.sc-zone-stats { margin-top: 12px; }
.sc-zone-stats table { width: 100%; border-collapse: collapse; font-size: 0.78rem; }
.sc-zone-stats th { text-align: left; font-weight: 700; text-transform: uppercase; font-size: 0.68rem; letter-spacing: 0.05em; color: #6b7280; padding: 4px 6px; border-bottom: 1px solid #e5e7eb; }
.sc-zone-stats td { padding: 4px 6px; border-bottom: 1px solid #f3f4f6; }
.sc-zone-stats .freq-diff-pos { color: #d72638; font-weight: 700; }
.sc-zone-stats .freq-diff-neg { color: #1e3a8a; font-weight: 700; }
.sc-loading { text-align: center; padding: 60px 20px; color: #888; font-size: 1rem; }
@media (max-width: 600px) {
    .sc-modal { max-width: 100%; border-radius: 8px; }
    .sc-header { padding: 14px 16px 8px; }
    .sc-body, .esc-body { padding: 10px 12px 16px; }
    .sc-player-info h2 { font-size: 1.1rem; }
}
</style>
<div class="trends-page">
    <div class="trends-header">
        <div>
            <h1 class="page-title">CHART GALLERY</h1>
            <p class="page-subtitle">Data-driven analysis for today's slate</p>
            {% if charts_last_updated %}
            <p class="charts-timestamp" style="font-size:0.8rem; color:#6b7280; margin-top:2px;">
                Charts last updated: {{ charts_last_updated.strftime('%b %d, %-I:%M %p') }}
                {% if not charts_stale %}<span style="color:#0f9d58; font-weight:600;">(today)</span>{% else %}<span style="color:#d72638; font-weight:600;">(stale)</span>{% endif %}
            </p>
            {% endif %}
        </div>
    </div>
    
    <div class="trends-section">
        <h2>Usage to Fantasy Points</h2>
        <p class="chart-description">Usage rate vs fantasy points. Bigger bubbles = better value (FP per $1K). Top-right = high-usage stars.</p>
        <div class="chart-container">
            <img src="/static/images/value_chart.png?v={{ cache_bust }}" alt="Usage to Fantasy Points" class="trend-chart">
        </div>
    </div>
    
    <div class="trends-section">
        <h2>Risk-Reward Frontier</h2>
        <p class="chart-description">Bottom-right = cash plays, top-left = GPP darts, top-right = slate breakers.</p>
        <div class="chart-container">
            <img src="/static/images/upside_chart.png?v={{ cache_bust }}" alt="Risk-Reward Frontier" class="trend-chart">
        </div>
    </div>
    
    <div class="trends-section">
        <h2>Referee Foul Tendencies</h2>
        <p class="chart-description">Tonight's crews plotted by foul volume (X) and home/away bias (Y). ▲ = home-favored, ▼ = road-favored.</p>
        <div class="chart-container">
            {% if ref_chart_exists %}
            <img src="/static/images/ref_foul_chart.png?v={{ cache_bust }}" alt="Referee Foul Chart" class="trend-chart">
            {% else %}
            <div style="text-align:center; padding:40px 20px; color:#888; font-size:1.1rem;">
                Referee assignments for tonight's games haven't been posted yet. Check back closer to tip-off.
            </div>
            {% endif %}
        </div>
    </div>
    
    <div class="trends-section">
        <h2>Defense vs Position Matchups</h2>
        <p class="chart-description">Green = soft matchup (target). Red = tough matchup (avoid).</p>
        <div class="chart-container">
            <img src="/static/images/dvp_heatmap.png?v={{ cache_bust }}" alt="DVP Heatmap" class="trend-chart dvp-heatmap">
        </div>
    </div>

    <div class="trends-section">
        <h2>Defense vs Archetype (DVA)</h2>
        <p class="chart-description">How teams defend playstyles, not positions. DVS multiplier combines archetype stat profile with defensive leaks. Toggle between FP/min differential and DVS multiplier. Hover cells for stat breakdown.</p>
        <div class="dva-controls">
            <button class="dva-mode-btn active" data-mode="dvs">DVS Multiplier</button>
            <button class="dva-mode-btn" data-mode="fp">FP/min Diff</button>
        </div>
        <div class="dva-table-wrapper">
            <div id="dva-loading" style="text-align:center; padding:40px; color:#888;">Loading DVA data...</div>
            <div id="dva-table-container" style="display:none; overflow-x:auto;"></div>
        </div>
    </div>

    <div class="trends-section">
        <h2>Team Offensive Scheme Profile</h2>
        <p class="chart-description">How teams distribute their possessions across play types. Radar shows scheme shape vs league average. Select a team to explore its offensive identity.</p>
        <div class="scheme-controls">
            <select id="scheme-team-select" class="scheme-select">
                <option value="">Loading teams...</option>
            </select>
            <div class="scheme-toggle">
                <button class="scheme-mode-btn active" data-mode="poss">Possession %</button>
                <button class="scheme-mode-btn" data-mode="ppp">Efficiency (PPP)</button>
            </div>
        </div>
        <div class="scheme-chart-row">
            <div class="scheme-radar-wrap">
                <canvas id="scheme-radar-chart"></canvas>
            </div>
            <div class="scheme-bar-wrap">
                <canvas id="scheme-bar-chart"></canvas>
            </div>
        </div>
        <div class="scheme-bar-legend">
            <span class="sbl-item"><span class="sbl-dot" style="background:#0f9d58"></span> Elite (75th+)</span>
            <span class="sbl-item"><span class="sbl-dot" style="background:#1e3a8a"></span> Above Avg (50th+)</span>
            <span class="sbl-item"><span class="sbl-dot" style="background:#d4af37"></span> Below Avg (25th+)</span>
            <span class="sbl-item"><span class="sbl-dot" style="background:#d72638"></span> Poor (Below 25th)</span>
        </div>
        <div id="scheme-summary" class="scheme-summary"></div>
    </div>

    <div class="trends-section">
        <h2>Defensive Scheme Vulnerabilities</h2>
        <p class="chart-description">How teams defend each play type. Green = they shut it down (low PPP allowed). Red = they bleed points. Use this to target opponents' weaknesses.</p>
        <div class="scheme-controls">
            <select id="def-scheme-team-select" class="scheme-select">
                <option value="">Loading teams...</option>
            </select>
        </div>
        <div class="def-scheme-chart-wrap">
            <canvas id="def-scheme-chart"></canvas>
        </div>
        <div class="scheme-bar-legend">
            <span class="sbl-item"><span class="sbl-dot" style="background:rgba(215,38,56,0.75)"></span> Weakness (allows more PPP than avg)</span>
            <span class="sbl-item"><span class="sbl-dot" style="background:rgba(15,157,88,0.75)"></span> Strength (allows less PPP than avg)</span>
            <span class="sbl-item"><span class="sbl-dot" style="background:rgba(107,114,128,0.5)"></span> Neutral</span>
            <span class="sbl-item"><span class="sbl-dot sbl-line" style="background:#9ca3af"></span> League Avg Line</span>
        </div>
        <div id="def-scheme-summary" class="def-scheme-summary"></div>
    </div>

    <div class="trends-section">
        <h2>Player Archetype Clusters</h2>
        <p class="chart-description">K-Means clustering groups players by how they actually play. Each dot is a player, positioned by PCA of 8 composite indices (Creation, Playmaking, Interior, Perimeter, Off-Ball, Rebounding, Defense, Size). Hover for details.</p>
        <div class="cluster-controls">
            <select id="cluster-team-filter" class="scheme-select">
                <option value="">All Teams</option>
            </select>
        </div>
        <div class="cluster-chart-wrapper">
            <canvas id="cluster-chart"></canvas>
        </div>
        <div id="cluster-legend" class="cluster-legend"></div>
    </div>

    <div class="trends-section">
        <h2>Defensive Shot Charts</h2>
        <p class="chart-description">Where opponents shoot against each team. Red zones = opponents shoot there MORE than league average. Blue zones = opponents shoot there LESS. Reveals rim protection, perimeter defense, and mid-range tendencies.</p>
        <div class="scheme-controls">
            <select id="def-shot-team-select" class="scheme-select">
                <option value="">Select a team...</option>
            </select>
        </div>
        <div id="def-shot-chart-container" style="display:none;">
            <div class="def-shot-header">
                <span id="def-shot-team-name" class="def-shot-team-label"></span>
                <span id="def-shot-total-fga" class="def-shot-fga-label"></span>
            </div>
            <div class="def-shot-canvas-wrap">
                <canvas id="def-shot-chart-canvas" width="500" height="470"></canvas>
            </div>
            <div id="def-shot-zone-stats" class="def-shot-zone-stats"></div>
            <div class="def-shot-legend">
                <span class="dsl-item"><span class="dsl-dot" style="background:rgba(215,38,56,0.6)"></span> Opponents shoot here MORE than avg</span>
                <span class="dsl-item"><span class="dsl-dot" style="background:rgba(30,58,138,0.6)"></span> Opponents shoot here LESS than avg</span>
            </div>
        </div>
        <div id="def-shot-loading" style="display:none; text-align:center; padding:40px; color:#888;">Loading defensive shot chart...</div>
        <div id="def-shot-empty" style="text-align:center; padding:40px 20px; color:#888; font-size:1.1rem;">
            Select a team above to see where opponents like to shoot against them.
        </div>
    </div>

    {% if explorer_players %}
    <div class="trends-section">
        <h2>Player Explorer</h2>
        <p class="chart-description">Browse today's full player pool. Click any player name to view their shot chart. Use the filters together to narrow your search.</p>
        <div class="explorer-filters">
            <input type="text" id="explorer-search" class="pool-search" placeholder="Search players...">
            <select id="explorer-pos-filter" class="pool-select">
                <option value="">All Positions</option>
                <option value="PG">PG</option>
                <option value="SG">SG</option>
                <option value="SF">SF</option>
                <option value="PF">PF</option>
                <option value="C">C</option>
            </select>
            <select id="explorer-team-filter" class="pool-select">
                <option value="">All Teams</option>
            </select>
            <select id="explorer-status-filter" class="pool-select">
                <option value="">All Status</option>
                <option value="healthy">Healthy</option>
                <option value="PROBABLE">Probable</option>
                <option value="QUESTIONABLE">Questionable</option>
                <option value="GTD">GTD</option>
                <option value="DOUBTFUL">Doubtful</option>
                <option value="OUT">Out</option>
            </select>
        </div>
        <div class="explorer-table-wrapper">
            <table class="player-table" id="explorer-table">
                <thead>
                    <tr>
                        <th data-sortable="string" class="col-pos">Pos</th>
                        <th data-sortable="string" class="col-name">Player</th>
                        <th data-sortable="string">Status</th>
                        <th data-sortable="string">Matchup</th>
                    </tr>
                </thead>
                <tbody>
                    {% for p in explorer_players %}
                    <tr data-name="{{ p.player_name }}"
                        data-pos="{{ p.get('true_position', '') }}"
                        data-team="{{ p.team }}"
                        data-opponent="{{ p.get('opponent', '') }}"
                        data-injury="{{ p.get('injury_status', '') }}">
                        <td class="col-pos"><span class="pos-badge">{{ p.get('true_position', '') }}</span></td>
                        <td class="col-name">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <img src="{{ headshots.get(p.player_name, '') }}" alt="" style="width:32px;height:32px;border-radius:0;object-fit:contain;flex-shrink:0;mix-blend-mode:multiply;" onerror="this.style.display='none'">
                                <span class="player-name-link" onclick="openExplorerShotChart('{{ p.player_name }}', event)" title="View shot chart">{{ p.player_name }}</span>
                            </div>
                        </td>
                        <td>
                            {% if p.get('injury_status') == 'OUT' %}
                            <span class="injury-tag tag-out">OUT</span>
                            {% elif p.get('injury_status') == 'DOUBTFUL' %}
                            <span class="injury-tag tag-doubtful">DTD</span>
                            {% elif p.get('injury_status') == 'QUESTIONABLE' %}
                            <span class="injury-tag tag-questionable">Q</span>
                            {% elif p.get('injury_status') == 'GTD' %}
                            <span class="injury-tag tag-gtd">GTD</span>
                            {% elif p.get('injury_status') == 'PROBABLE' %}
                            <span class="injury-tag tag-probable">P</span>
                            {% endif %}
                        </td>
                        <td>
                            <span class="matchup-text">{{ p.team }} <span class="matchup-vs">vs</span> {{ p.get('opponent', '') }}</span>
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    {% endif %}

    {% if top_value %}
    <div class="trends-section">
        <h2>Top Value Plays</h2>
        <p class="chart-description">Players outperforming their salary tier. Value vs Tier shows how much better than peers at similar price.</p>
        <div class="value-table">
            <table>
                <thead>
                    <tr>
                        <th data-sortable="string">Player</th>
                        <th data-sortable="string">Team</th>
                        <th data-sortable="number">Salary</th>
                        <th data-sortable="number">Proj FP</th>
                        <th data-sortable="number">Floor</th>
                        <th data-sortable="number">Ceiling</th>
                        <th data-sortable="number">FP/$1k</th>
                        <th data-sortable="number">vs Tier</th>
                        <th data-sortable="string">Tier</th>
                        <th data-sortable="string">Archetype</th>
                    </tr>
                </thead>
                <tbody>
                    {% for player in top_value %}
                    <tr>
                        <td>{{ player.player_name }}</td>
                        <td>{{ player.team }}</td>
                        <td>${{ "{:,}".format(player.salary|int) }}</td>
                        <td>{{ "%.1f"|format(player.proj_fp) }}</td>
                        <td>{{ "%.1f"|format(player.get('floor', 0)) }}</td>
                        <td>{{ "%.1f"|format(player.get('ceiling', 0)) }}</td>
                        <td class="value-cell">{{ "%.2f"|format(player.get('value_ratio', player.get('value', 0))) }}</td>
                        <td class="{% if player.get('value_vs_tier', 0) > 0 %}positive-value{% else %}negative-value{% endif %}">{{ "%+.1f"|format((player.get('value_vs_tier', 0) * 100)) }}%</td>
                        <td>{{ player.get('tier', player.get('salary_tier', '')) }}</td>
                        <td><span class="archetype-badge archetype-{{ player.get('archetype', 'Unknown')|lower|replace(' ', '-')|replace('(', '')|replace(')', '') }}">{{ player.get('archetype', '') }}</span></td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    {% endif %}
    
    {% if targeted %}
    <div class="trends-section">
        <h2>Targeted Stat Plays</h2>
        <p class="chart-description">Players facing teams that give up extra fantasy points in specific stats. Sorted by FP impact.</p>
        <div class="targeted-table">
            <table>
                <thead>
                    <tr>
                        <th>Player</th>
                        <th>Pos</th>
                        <th>vs</th>
                        <th>Stat</th>
                        <th>Avg</th>
                        <th>+FP</th>
                        <th>Matchup Note</th>
                    </tr>
                </thead>
                <tbody>
                    {% for play in targeted %}
                    <tr>
                        <td>{{ play.player_name }}</td>
                        <td>{{ play.position }}</td>
                        <td>{{ play.opponent }}</td>
                        <td>{{ play.stat }}</td>
                        <td>{{ play.player_avg }}</td>
                        <td class="edge-cell">+{{ play.extra_fp }}</td>
                        <td class="matchup-note">{{ play.recommendation }}</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    {% endif %}
    
    {% if props %}
    <div class="trends-section">
        <h2>Prop Recommendations</h2>
        <p class="chart-description">Our projections vs FanDuel book lines. Sorted by largest edge where our model disagrees with the market.</p>
        <div class="table-controls">
            <input type="text" class="table-search" data-table="props-table" placeholder="Search player...">
        </div>
        <div class="props-table">
            <table id="props-table">
                <thead>
                    <tr>
                        <th data-sortable="text">Player</th>
                        <th data-sortable="text">vs</th>
                        <th data-sortable="text">Stat</th>
                        <th data-sortable="number">Avg</th>
                        <th data-sortable="number">Proj</th>
                        <th data-sortable="number">Line</th>
                        <th data-sortable="number">Edge%</th>
                        <th data-sortable="text">Call</th>
                        <th>Trend</th>
                    </tr>
                </thead>
                <tbody>
                    {% for prop in props %}
                    <tr>
                        <td>{{ prop.player }}</td>
                        <td>{{ prop.opponent }}</td>
                        <td>{{ prop.stat }}</td>
                        <td>{{ prop.player_avg }}</td>
                        <td>{{ prop.adjusted_avg }}</td>
                        <td>{{ prop.book_line if prop.book_line is not none and prop.book_line == prop.book_line else '—' }}</td>
                        <td class="{% if prop.vs_book_edge is not none and prop.vs_book_edge == prop.vs_book_edge %}{% if prop.vs_book_edge > 15 %}fp-positive{% elif prop.vs_book_edge < -15 %}fp-negative{% else %}fp-neutral{% endif %}{% endif %}">{{ '%+.1f'|format(prop.vs_book_edge) if prop.vs_book_edge is not none and prop.vs_book_edge == prop.vs_book_edge else '—' }}</td>
                        <td class="{% if prop.recommendation == 'OVER' %}over-cell{% else %}under-cell{% endif %}">{{ prop.recommendation }}</td>
                        <td class="trend-btn-cell"><button class="trend-analysis-btn" data-player="{{ prop.player }}" data-stat="{{ prop.stat }}" data-line="{{ prop.book_line if prop.book_line is not none and prop.book_line == prop.book_line else '' }}" data-call="{{ prop.recommendation }}" title="View trend">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                        </button></td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    {% endif %}
</div>

<div id="explorer-shot-chart-modal" class="sc-modal-overlay" style="display:none;" onclick="if(event.target===this)closeExplorerShotChart()">
    <div class="sc-modal">
        <button class="sc-close" onclick="closeExplorerShotChart()">&times;</button>
        <div class="sc-header">
            <div class="sc-player-info">
                <h2 id="esc-player-name"></h2>
                <span id="esc-archetype-badge" class="sc-archetype"></span>
                <span id="esc-total-fga" class="sc-fga-count"></span>
            </div>
            <div class="sc-legend">
                <span class="sc-leg-item"><span class="sc-leg-dot" style="background:#d72638"></span> More shots than league avg</span>
                <span class="sc-leg-item"><span class="sc-leg-dot" style="background:#1e3a8a"></span> Fewer shots than league avg</span>
            </div>
        </div>
        <div class="esc-body" style="display:none;">
            <div class="sc-canvas-wrap">
                <canvas id="esc-canvas" width="500" height="470"></canvas>
            </div>
            <div class="sc-zone-stats" id="esc-zone-stats"></div>
        </div>
        <div id="esc-loading" class="sc-loading">Loading shot chart...</div>
    </div>
</div>

<div id="trend-modal" class="trend-modal-overlay" style="display:none;">
    <div class="trend-modal">
        <div class="trend-modal-header">
            <h3 id="trend-modal-title"></h3>
            <button class="trend-modal-close" onclick="closeTrendModal()">&times;</button>
        </div>
        <div class="trend-modal-body">
            <canvas id="trend-chart" height="260"></canvas>
        </div>
        <div class="trend-modal-legend">
            <span class="legend-item"><span class="legend-line legend-blue"></span> FanDuel Line</span>
            <span class="legend-item"><span class="legend-line legend-grey"></span> Player Average</span>
        </div>
        <div class="trend-modal-footer">
            <span id="trend-modal-avg"></span>
            <span id="trend-modal-call"></span>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
const ARCHETYPE_COLORS = {
    'Playmaker': '#00E5FF',
    'Combo Guard': '#FF6D00',
    '3-and-D Wing': '#39FF14',
    'Shooting Wing': '#B388FF',
    'Scoring Wing': '#FF1744',
    'Stretch 4': '#D4AF37',
    'Stretch 5': '#AA00FF',
    'Traditional Big': '#607D8B',
    'Versatile Big': '#FF4081',
    'Point Center': '#00BFA5',
    'Point Forward': '#FFEA00',
};

let dvaMode = 'dvs';
let dvaData = null;

async function loadDVA() {
    try {
        const res = await fetch('/api/dva');
        dvaData = await res.json();
        if (dvaData.error || !dvaData.teams || dvaData.teams.length === 0) {
            document.getElementById('dva-loading').textContent = dvaData.error || 'No DVA data available.';
            return;
        }
        renderDVA();
    } catch(e) {
        document.getElementById('dva-loading').textContent = 'Failed to load DVA data.';
    }
}

function dvaColor(val, mode) {
    const maxVal = mode === 'dvs' ? 20 : 0.15;
    const t = Math.max(-1, Math.min(1, val / maxVal));
    const norm = (t + 1) / 2;
    let r, g, b;
    if (norm >= 0.5) {
        const p = (norm - 0.5) * 2;
        r = Math.round(255 * (1 - p) + 26 * p);
        g = Math.round(255 * (1 - p) + 150 * p);
        b = Math.round(191 * (1 - p * 0.8) + 65 * p);
    } else {
        const p = norm * 2;
        r = Math.round(215 * (1 - p) + 255 * p);
        g = Math.round(48 * (1 - p) + 255 * p);
        b = Math.round(39 * (1 - p) + 191 * p);
    }
    return `rgb(${r},${g},${b})`;
}

function dvaTextColor(val, mode) {
    const maxVal = mode === 'dvs' ? 20 : 0.15;
    const t = Math.abs(val / maxVal);
    return t > 0.7 ? '#fff' : '#222';
}

function buildTooltip(cell, team, arch) {
    const d = dvaData.data[team][arch];
    const statNames = {pts:'PTS', reb:'REB', ast:'AST', stl:'STL', blk:'BLK', fg3m:'3PM', tov:'TOV'};
    let html = '<div class="dva-tooltip">';
    html += '<div class="dva-tooltip-title">' + team + ' vs ' + arch + '</div>';
    html += '<div class="dva-tooltip-row"><span>FP/min diff:</span><span>' + (d.fp_pm_diff >= 0 ? '+' : '') + d.fp_pm_diff.toFixed(4) + '</span></div>';
    html += '<div class="dva-tooltip-row"><span>DVS Multiplier:</span><span>' + (d.dvs_multiplier >= 0 ? '+' : '') + d.dvs_multiplier.toFixed(2) + '%</span></div>';
    html += '<div class="dva-tooltip-row"><span>Sample:</span><span>' + d.sample_n + ' games</span></div>';
    html += '<div class="dva-tooltip-divider"></div>';
    html += '<div class="dva-tooltip-subtitle">Stat Leak (per min vs avg)</div>';
    for (const [k, label] of Object.entries(statNames)) {
        const v = d.stat_diffs[k];
        const cls = v > 0.001 ? 'dva-pos' : v < -0.001 ? 'dva-neg' : '';
        html += '<div class="dva-tooltip-row ' + cls + '"><span>' + label + ':</span><span>' + (v >= 0 ? '+' : '') + v.toFixed(4) + '</span></div>';
    }
    if (d.dvs_components) {
        html += '<div class="dva-tooltip-divider"></div>';
        html += '<div class="dva-tooltip-subtitle">DVS Components</div>';
        for (const [k, label] of Object.entries(statNames)) {
            const v = d.dvs_components[k];
            if (Math.abs(v) >= 0.01) {
                const cls = v > 0 ? 'dva-pos' : 'dva-neg';
                html += '<div class="dva-tooltip-row ' + cls + '"><span>' + label + ':</span><span>' + (v >= 0 ? '+' : '') + v.toFixed(2) + '%</span></div>';
            }
        }
    }
    html += '</div>';
    return html;
}

function renderDVA() {
    if (!dvaData || !dvaData.teams) return;
    const container = document.getElementById('dva-table-container');
    const isMobile = window.innerWidth < 768;
    const shortNames = {
        'Playmaker': 'PM', 'Combo Guard': 'CG',
        '3-and-D Wing': '3&D', 'Shooting Wing': 'SH W', 'Scoring Wing': 'SC W',
        'Stretch 4': 'S4', 'Stretch 5': 'S5',
        'Traditional Big': 'Trd B', 'Versatile Big': 'Vrs B',
        'Point Center': 'PC', 'Point Forward': 'PF'
    };

    let html = '<table class="dva-table"><thead><tr><th class="dva-team-col">Team</th>';
    dvaData.archetypes.forEach(a => {
        const label = isMobile ? (shortNames[a] || a.substring(0,4)) : a;
        html += '<th class="dva-arch-col">' + label + '</th>';
    });
    html += '</tr></thead><tbody>';

    dvaData.teams.forEach(team => {
        html += '<tr><td class="dva-team-cell">' + team + '</td>';
        dvaData.archetypes.forEach(arch => {
            const d = dvaData.data[team] && dvaData.data[team][arch];
            if (!d) { html += '<td class="dva-cell">-</td>'; return; }
            const val = dvaMode === 'dvs' ? d.dvs_multiplier : d.fp_pm_diff;
            const bg = dvaColor(val, dvaMode);
            const tc = dvaTextColor(val, dvaMode);
            const display = dvaMode === 'dvs' ? (val >= 0 ? '+' : '') + val.toFixed(1) + '%' : (val >= 0 ? '+' : '') + val.toFixed(3);
            html += '<td class="dva-cell" style="background:' + bg + ';color:' + tc + '" data-team="' + team + '" data-arch="' + arch + '">' + display + '</td>';
        });
        html += '</tr>';
    });
    html += '</tbody></table>';
    container.innerHTML = html;
    container.style.display = 'block';
    document.getElementById('dva-loading').style.display = 'none';

    container.querySelectorAll('.dva-cell[data-team]').forEach(cell => {
        let tooltipEl = null;
        cell.addEventListener('mouseenter', function(e) {
            const team = this.dataset.team;
            const arch = this.dataset.arch;
            if (!dvaData.data[team] || !dvaData.data[team][arch]) return;
            tooltipEl = document.createElement('div');
            tooltipEl.className = 'dva-tooltip-wrap';
            tooltipEl.innerHTML = buildTooltip(this, team, arch);
            document.body.appendChild(tooltipEl);
            const rect = this.getBoundingClientRect();
            tooltipEl.style.left = Math.min(rect.left, window.innerWidth - 260) + 'px';
            tooltipEl.style.top = (rect.bottom + 6 + window.scrollY) + 'px';
        });
        cell.addEventListener('mouseleave', function() {
            if (tooltipEl) { tooltipEl.remove(); tooltipEl = null; }
        });
    });
}

document.querySelectorAll('.dva-mode-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.dva-mode-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        dvaMode = this.dataset.mode;
        renderDVA();
    });
});

loadDVA();

let clusterChart = null;
let clusterData = null;

async function loadClusterChart() {
    try {
        const res = await fetch('/api/archetype-clusters');
        clusterData = await res.json();
        if (!clusterData.players || clusterData.players.length === 0) {
            document.querySelector('.cluster-chart-wrapper').innerHTML = '<div style="text-align:center;padding:40px 20px;color:#888;font-size:1.1rem;">Archetype clustering data not yet available. Run the daily update to generate clusters.</div>';
            return;
        }

        const teams = [...new Set(clusterData.players.map(p => p.team))].sort();
        const teamSel = document.getElementById('cluster-team-filter');
        if (teamSel) {
            teams.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t;
                opt.textContent = t;
                teamSel.appendChild(opt);
            });
            teamSel.addEventListener('change', () => renderClusterChart(teamSel.value));
        }

        renderClusterChart('');
    } catch(e) {
        console.error('Cluster chart error:', e);
    }
}

function renderClusterChart(filterTeam) {
    if (!clusterData) return;

    const grouped = {};
    clusterData.archetypes.forEach(a => { grouped[a] = []; });
    clusterData.players.forEach(p => {
        if (!grouped[p.archetype]) grouped[p.archetype] = [];
        grouped[p.archetype].push(p);
    });

    const isMobile = window.innerWidth < 768;
    const isFiltered = filterTeam && filterTeam !== '';

    const datasets = Object.entries(grouped).map(([arch, players]) => {
        const data = players.map(p => ({ x: p.x, y: p.y, name: p.name, team: p.team, pts: p.pts, reb: p.reb, ast: p.ast, usg: p.usg }));
        return {
            label: arch,
            data: data,
            backgroundColor: data.map(d => {
                const color = ARCHETYPE_COLORS[arch] || '#888';
                if (!isFiltered) return color + 'cc';
                return d.team === filterTeam ? color + 'ff' : color + '18';
            }),
            borderColor: data.map(d => {
                const color = ARCHETYPE_COLORS[arch] || '#888';
                if (!isFiltered) return color;
                return d.team === filterTeam ? color : color + '30';
            }),
            borderWidth: isMobile ? 1 : 1.5,
            pointRadius: data.map(d => {
                if (!isFiltered) return isMobile ? 3.5 : 6;
                return d.team === filterTeam ? (isMobile ? 5 : 8) : (isMobile ? 2 : 3);
            }),
            pointHoverRadius: isMobile ? 6 : 9,
        };
    });

    const ctx = document.getElementById('cluster-chart').getContext('2d');
    if (clusterChart) clusterChart.destroy();

    clusterChart = new Chart(ctx, {
        type: 'scatter',
        data: { datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: isMobile ? { top: 4, right: 4, bottom: 4, left: 4 } : { top: 10, right: 10, bottom: 10, left: 10 }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const p = context.raw;
                            return [
                                p.name + ' (' + p.team + ')',
                                context.dataset.label,
                                'PTS/100: ' + p.pts + '  REB/100: ' + p.reb,
                                'AST/100: ' + p.ast + '  USG%: ' + p.usg
                            ];
                        }
                    },
                    backgroundColor: '#111',
                    titleFont: { family: 'Marvel', size: isMobile ? 11 : 13 },
                    bodyFont: { family: 'Marvel', size: isMobile ? 10 : 12 },
                    padding: isMobile ? 6 : 10,
                    cornerRadius: 6,
                }
            },
            scales: {
                x: {
                    title: { display: !isMobile, text: 'PC1 (' + clusterData.variance_explained[0] + '% var)', font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' },
                    grid: { color: '#e5e7eb' },
                    ticks: { font: { family: 'Marvel', size: isMobile ? 9 : 12 }, maxTicksLimit: isMobile ? 5 : 10 }
                },
                y: {
                    title: { display: !isMobile, text: 'PC2 (' + clusterData.variance_explained[1] + '% var)', font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' },
                    grid: { color: '#e5e7eb' },
                    ticks: { font: { family: 'Marvel', size: isMobile ? 9 : 12 }, maxTicksLimit: isMobile ? 5 : 10 }
                }
            }
        }
    });

    const legendEl = document.getElementById('cluster-legend');
    legendEl.innerHTML = clusterData.archetypes.map(arch => {
        const color = ARCHETYPE_COLORS[arch] || '#888';
        const count = isFiltered ? (grouped[arch] || []).filter(p => p.team === filterTeam).length : (grouped[arch] || []).length;
        return '<span class="cluster-legend-item" data-arch="' + arch + '">' +
               '<span class="cluster-legend-dot" style="background:' + color + '"></span>' +
               arch + ' <span class="cluster-legend-count">(' + count + ')</span></span>';
    }).join('');

    legendEl.querySelectorAll('.cluster-legend-item').forEach(item => {
        item.addEventListener('click', function() {
            const arch = this.dataset.arch;
            const ds = clusterChart.data.datasets.find(d => d.label === arch);
            if (ds) {
                const idx = clusterChart.data.datasets.indexOf(ds);
                const meta = clusterChart.getDatasetMeta(idx);
                meta.hidden = !meta.hidden;
                this.classList.toggle('cluster-legend-dimmed');
                clusterChart.update();
            }
        });
    });
}

loadClusterChart();

let trendChart = null;

document.querySelectorAll('.trend-analysis-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const player = this.dataset.player;
        const stat = this.dataset.stat;
        const line = this.dataset.line ? parseFloat(this.dataset.line) : null;
        const call = this.dataset.call;
        openTrendModal(player, stat, line, call);
    });
});

async function openTrendModal(player, stat, line, call) {
    const modal = document.getElementById('trend-modal');
    const title = document.getElementById('trend-modal-title');
    const avgEl = document.getElementById('trend-modal-avg');
    const callEl = document.getElementById('trend-modal-call');
    
    title.textContent = player + ' — ' + stat + ' (Last 10 Games)';
    avgEl.textContent = 'Loading...';
    callEl.textContent = '';
    modal.style.display = 'flex';

    try {
        const res = await fetch('/api/player-trend/' + encodeURIComponent(player) + '/' + encodeURIComponent(stat) + '?n=10');
        const data = await res.json();
        if (data.error && (!data.games || data.games.length === 0)) {
            avgEl.textContent = 'No game log data available.';
            return;
        }
        const labels = data.games.map(g => {
            const m = g.matchup || '';
            const parts = m.split(' ');
            return parts[parts.length - 1] || g.date;
        });
        const values = data.games.map(g => g.value);
        const avg = data.avg;

        avgEl.textContent = '10-Game Avg: ' + avg;
        if (call) {
            callEl.textContent = call;
            callEl.className = call === 'OVER' ? 'trend-call-over' : 'trend-call-under';
        }

        const barColors = values.map(v => {
            if (line !== null) {
                return v >= line ? '#111827' : '#d1d5db';
            }
            return v >= avg ? '#111827' : '#d1d5db';
        });

        const ctx = document.getElementById('trend-chart').getContext('2d');
        if (trendChart) trendChart.destroy();

        const datasets = [{
            label: stat,
            data: values,
            backgroundColor: barColors,
            borderRadius: 4,
            barPercentage: 0.7
        }];

        trendChart = new Chart(ctx, {
            type: 'bar',
            data: { labels, datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: { beginAtZero: true, grid: { color: '#e5e7eb' }, ticks: { font: { family: 'Marvel' } }, title: { display: true, text: stat, font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' } },
                    x: { grid: { display: false }, ticks: { font: { family: 'Marvel', size: 11 } }, title: { display: true, text: 'Game', font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' } }
                }
            },
            plugins: [{
                id: 'customLines',
                afterDraw(chart) {
                    const ctx = chart.ctx;
                    const yAxis = chart.scales.y;
                    const xAxis = chart.scales.x;
                    
                    if (line !== null) {
                        const yLine = yAxis.getPixelForValue(line);
                        ctx.save();
                        ctx.strokeStyle = '#2563eb';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([6, 4]);
                        ctx.beginPath();
                        ctx.moveTo(xAxis.left, yLine);
                        ctx.lineTo(xAxis.right, yLine);
                        ctx.stroke();
                        ctx.restore();
                    }
                    
                    const yAvg = yAxis.getPixelForValue(avg);
                    ctx.save();
                    ctx.strokeStyle = '#6b7280';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(xAxis.left, yAvg);
                    ctx.lineTo(xAxis.right, yAvg);
                    ctx.stroke();
                    ctx.restore();
                }
            }]
        });
    } catch(e) {
        avgEl.textContent = 'Error loading trend data.';
    }
}

function closeTrendModal() {
    document.getElementById('trend-modal').style.display = 'none';
    if (trendChart) { trendChart.destroy(); trendChart = null; }
}

document.getElementById('trend-modal').addEventListener('click', function(e) {
    if (e.target === this) closeTrendModal();
});

let schemeData = null;
let schemeRadar = null;
let schemeBar = null;
let defSchemeChart = null;
let schemeMode = 'poss';

const SCHEME_COLORS = {
    team: { bg: 'rgba(17,24,39,0.25)', border: '#111827' },
    avg: { bg: 'rgba(107,114,128,0.12)', border: '#9ca3af' },
};

const PLAY_TYPE_ORDER = ['Isolation','Transition','PRBallHandler','PRRollman','Postup','Spotup','Handoff','Cut','OffScreen'];

async function loadSchemeData() {
    try {
        const res = await fetch('/api/team-schemes');
        schemeData = await res.json();
        if (schemeData.error || !schemeData.teams || schemeData.teams.length === 0) {
            document.getElementById('scheme-summary').textContent = schemeData.error || 'No scheme data available.';
            document.getElementById('def-scheme-summary').textContent = schemeData.error || 'No scheme data available.';
            return;
        }
        const sel = document.getElementById('scheme-team-select');
        const defSel = document.getElementById('def-scheme-team-select');
        sel.innerHTML = '';
        defSel.innerHTML = '';
        schemeData.teams.forEach(t => {
            sel.innerHTML += '<option value="' + t + '">' + t + '</option>';
            defSel.innerHTML += '<option value="' + t + '">' + t + '</option>';
        });
        sel.value = schemeData.teams.includes('OKC') ? 'OKC' : schemeData.teams[0];
        defSel.value = schemeData.teams.includes('OKC') ? 'OKC' : schemeData.teams[0];
        renderSchemeRadar(sel.value);
        renderDefScheme(defSel.value);
    } catch(e) {
        document.getElementById('scheme-summary').textContent = 'Failed to load scheme data.';
    }
}

function getPlayLabel(pt) {
    const labels = {
        'Isolation':'ISOLATION','Transition':'TRANSITION','PRBallHandler':'PnR BALL HANDLER','PRRollman':'PnR ROLL MAN',
        'Postup':'POST UP','Spotup':'SPOT UP','Handoff':'HANDOFF','Cut':'CUT','OffScreen':'OFF SCREEN'
    };
    return labels[pt] || pt;
}

function renderSchemeRadar(team) {
    if (!schemeData || !schemeData.offense[team]) return;
    const plays = schemeData.offense[team].filter(p => PLAY_TYPE_ORDER.includes(p.play_type));
    plays.sort((a,b) => PLAY_TYPE_ORDER.indexOf(a.play_type) - PLAY_TYPE_ORDER.indexOf(b.play_type));
    const labels = plays.map(p => getPlayLabel(p.play_type));
    const isEff = schemeMode === 'ppp';
    const teamVals = plays.map(p => isEff ? p.ppp : p.poss_pct);
    const avgVals = plays.map(p => {
        const avg = schemeData.league_avg[p.play_type];
        return avg ? (isEff ? avg.ppp : avg.poss_pct) : 0;
    });

    const ctx = document.getElementById('scheme-radar-chart').getContext('2d');
    if (schemeRadar) schemeRadar.destroy();
    schemeRadar = new Chart(ctx, {
        type: 'radar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: team,
                    data: teamVals,
                    backgroundColor: SCHEME_COLORS.team.bg,
                    borderColor: SCHEME_COLORS.team.border,
                    borderWidth: 2.5,
                    pointBackgroundColor: SCHEME_COLORS.team.border,
                    pointRadius: 4,
                },
                {
                    label: 'League Avg',
                    data: avgVals,
                    backgroundColor: SCHEME_COLORS.avg.bg,
                    borderColor: SCHEME_COLORS.avg.border,
                    borderWidth: 1.5,
                    borderDash: [5,3],
                    pointBackgroundColor: SCHEME_COLORS.avg.border,
                    pointRadius: 3,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom', labels: { font: { family: 'Marvel', size: 12 }, usePointStyle: true, padding: 14 } },
                tooltip: {
                    backgroundColor: '#111',
                    titleFont: { family: 'Marvel', size: 13 },
                    bodyFont: { family: 'Marvel', size: 12 },
                    callbacks: {
                        label: function(ctx) {
                            return ctx.dataset.label + ': ' + (isEff ? ctx.raw.toFixed(3) + ' PPP' : ctx.raw.toFixed(1) + '%');
                        }
                    }
                }
            },
            scales: {
                r: {
                    beginAtZero: true,
                    pointLabels: { font: { family: 'Marvel', size: 11, weight: 'bold' }, color: '#374151' },
                    ticks: { font: { family: 'Marvel', size: 9 }, backdropColor: 'transparent', stepSize: isEff ? 0.2 : 5 },
                    grid: { color: '#e5e7eb' },
                    angleLines: { color: '#e5e7eb' }
                }
            }
        }
    });

    const barPlays = [...plays].sort((a,b) => b.poss_pct - a.poss_pct).slice(0, 7);
    const barLabels = barPlays.map(p => getPlayLabel(p.play_type));
    const barPctile = barPlays.map(p => p.percentile);
    const barColors = barPctile.map(v => v >= 75 ? '#0f9d58' : v >= 50 ? '#1e3a8a' : v >= 25 ? '#d4af37' : '#d72638');

    const bCtx = document.getElementById('scheme-bar-chart').getContext('2d');
    if (schemeBar) schemeBar.destroy();
    schemeBar = new Chart(bCtx, {
        type: 'bar',
        data: {
            labels: barLabels,
            datasets: [{
                label: 'Percentile',
                data: barPctile,
                backgroundColor: barColors,
                borderRadius: 4,
                barPercentage: 0.65,
            }]
        },
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: { display: true, text: 'Efficiency Percentile by Play Type', font: { family: 'Marvel', size: 14, weight: 'bold' }, color: '#111827', padding: { bottom: 8 } },
                tooltip: {
                    backgroundColor: '#111',
                    titleFont: { family: 'Marvel', size: 13 },
                    bodyFont: { family: 'Marvel', size: 12 },
                    callbacks: {
                        label: function(ctx) {
                            const p = barPlays[ctx.dataIndex];
                            return [ctx.raw + 'th percentile', p.poss_pct + '% of poss', p.ppp.toFixed(3) + ' PPP', p.efg_pct + '% eFG'];
                        }
                    }
                }
            },
            scales: {
                x: { min: 0, max: 100, title: { display: true, text: 'League Percentile', font: { family: 'Marvel', size: 12, weight: 'bold' }, color: '#374151' }, grid: { color: '#e5e7eb' }, ticks: { font: { family: 'Marvel', size: 10 } } },
                y: { grid: { display: false }, ticks: { font: { family: 'Marvel', size: 11, weight: 'bold' }, color: '#374151' } }
            }
        }
    });

    const topPlay = plays.reduce((a,b) => a.poss_pct > b.poss_pct ? a : b);
    const bestEff = plays.reduce((a,b) => a.percentile > b.percentile ? a : b);
    document.getElementById('scheme-summary').innerHTML =
        '<div class="scheme-insight"><strong>' + team + ' Offensive Identity:</strong> ' +
        'Runs ' + getPlayLabel(topPlay.play_type) + ' most often (' + topPlay.poss_pct + '% of possessions). ' +
        'Elite at ' + getPlayLabel(bestEff.play_type) + ' (' + bestEff.percentile + 'th percentile, ' + bestEff.ppp.toFixed(3) + ' PPP).</div>';
}

function renderDefScheme(team) {
    if (!schemeData || !schemeData.defense[team]) return;
    const plays = schemeData.defense[team].filter(p => PLAY_TYPE_ORDER.includes(p.play_type));
    plays.sort((a,b) => PLAY_TYPE_ORDER.indexOf(a.play_type) - PLAY_TYPE_ORDER.indexOf(b.play_type));
    const labels = plays.map(p => getPlayLabel(p.play_type));
    const pppVals = plays.map(p => p.ppp);
    const avgPPP = plays.map(p => { const a = schemeData.league_avg[p.play_type]; return a ? a.ppp : 0; });
    const barColors = plays.map((p,i) => p.ppp > avgPPP[i] + 0.03 ? 'rgba(215,38,56,0.75)' : p.ppp < avgPPP[i] - 0.03 ? 'rgba(15,157,88,0.75)' : 'rgba(107,114,128,0.5)');

    const ctx = document.getElementById('def-scheme-chart').getContext('2d');
    if (defSchemeChart) defSchemeChart.destroy();
    defSchemeChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: team + ' Allows',
                    data: pppVals,
                    backgroundColor: barColors,
                    borderRadius: 4,
                    barPercentage: 0.55,
                    order: 1,
                },
                {
                    label: 'League Avg',
                    data: avgPPP,
                    type: 'line',
                    borderColor: '#9ca3af',
                    borderWidth: 2,
                    borderDash: [6,3],
                    pointBackgroundColor: '#9ca3af',
                    pointRadius: 4,
                    fill: false,
                    order: 0,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: {
                    backgroundColor: '#111',
                    titleFont: { family: 'Marvel', size: 13 },
                    bodyFont: { family: 'Marvel', size: 12 },
                    callbacks: {
                        label: function(ctx) {
                            const idx = ctx.dataIndex;
                            const p = plays[idx];
                            if (ctx.dataset.label.includes('Avg')) return 'Avg: ' + ctx.raw.toFixed(3) + ' PPP';
                            const diff = (p.ppp - avgPPP[idx]).toFixed(3);
                            const sign = diff >= 0 ? '+' : '';
                            return [p.ppp.toFixed(3) + ' PPP allowed', sign + diff + ' vs avg', p.percentile + 'th percentile', p.score_pct + '% scoring rate'];
                        }
                    }
                }
            },
            scales: {
                y: { title: { display: true, text: 'Points Per Possession Allowed', font: { family: 'Marvel', size: 12, weight: 'bold' }, color: '#374151' }, grid: { color: '#e5e7eb' }, ticks: { font: { family: 'Marvel', size: 10 } } },
                x: { grid: { display: false }, ticks: { font: { family: 'Marvel', size: 11, weight: 'bold' }, color: '#374151' } }
            }
        }
    });

    const worstDef = plays.reduce((a,b) => a.percentile < b.percentile ? a : b);
    const bestDef = plays.reduce((a,b) => a.percentile > b.percentile ? a : b);
    document.getElementById('def-scheme-summary').innerHTML =
        '<div class="scheme-insight"><strong>' + team + ' Defensive Vulnerabilities:</strong> ' +
        'Weakest vs ' + getPlayLabel(worstDef.play_type) + ' (' + worstDef.percentile + 'th percentile, ' + worstDef.ppp.toFixed(3) + ' PPP allowed). ' +
        'Strongest vs ' + getPlayLabel(bestDef.play_type) + ' (' + bestDef.percentile + 'th percentile, ' + bestDef.ppp.toFixed(3) + ' PPP allowed).</div>';
}

document.getElementById('scheme-team-select').addEventListener('change', function() { renderSchemeRadar(this.value); });
document.getElementById('def-scheme-team-select').addEventListener('change', function() { renderDefScheme(this.value); });
document.querySelectorAll('.scheme-mode-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.scheme-mode-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        schemeMode = this.dataset.mode;
        const team = document.getElementById('scheme-team-select').value;
        if (team) renderSchemeRadar(team);
    });
});

loadSchemeData();

(function() {
    var defShotSelect = document.getElementById('def-shot-team-select');
    var defShotContainer = document.getElementById('def-shot-chart-container');
    var defShotLoading = document.getElementById('def-shot-loading');
    var defShotEmpty = document.getElementById('def-shot-empty');

    fetch('/api/team-defense-shot-chart-teams')
        .then(function(r) { return r.json(); })
        .then(function(data) {
            if (!data.teams || data.teams.length === 0) return;
            data.teams.forEach(function(t) {
                var opt = document.createElement('option');
                opt.value = t;
                opt.textContent = t;
                defShotSelect.appendChild(opt);
            });
        });

    defShotSelect.addEventListener('change', function() {
        var team = this.value;
        if (!team) {
            defShotContainer.style.display = 'none';
            defShotEmpty.style.display = 'block';
            return;
        }
        defShotEmpty.style.display = 'none';
        defShotContainer.style.display = 'none';
        defShotLoading.style.display = 'block';

        fetch('/api/team-defense-shot-chart/' + encodeURIComponent(team))
            .then(function(r) { return r.json(); })
            .then(function(data) {
                defShotLoading.style.display = 'none';
                if (data.error || !data.zones) {
                    defShotEmpty.style.display = 'block';
                    defShotEmpty.textContent = data.error || 'No data available';
                    return;
                }
                defShotContainer.style.display = 'block';
                document.getElementById('def-shot-team-name').textContent = data.team_name + ' (' + data.team + ')';
                document.getElementById('def-shot-total-fga').textContent = data.total_fga.toLocaleString() + ' Opponent FGA';
                renderDefShotChart(document.getElementById('def-shot-chart-canvas'), data);
                renderDefShotStats(data);
            })
            .catch(function() {
                defShotLoading.style.display = 'none';
                defShotEmpty.style.display = 'block';
                defShotEmpty.textContent = 'Failed to load defensive shot chart';
            });
    });

    function renderDefShotChart(canvas, data) {
        var W = 500, H = 470;
        var dpr = window.devicePixelRatio || 1;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        var ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, W, H);

        var S = 9;
        var bx = 250;
        var baseY = 452;
        var by = baseY - Math.round(5.25 * S);

        var RA_R = Math.round(4 * S);
        var LANE_HW = Math.round(8 * S);
        var FT_DIST = Math.round(13.75 * S);
        var FT_R = Math.round(6 * S);
        var THREE_R = Math.round(23.75 * S);
        var THREE_STRAIGHT_X = Math.round(22 * S);
        var COURT_HW = Math.round(25 * S);
        var THREE_ANG = Math.acos(THREE_STRAIGHT_X / THREE_R);
        var CORNER_TOP_Y = by - Math.round(Math.sqrt(THREE_R * THREE_R - THREE_STRAIGHT_X * THREE_STRAIGHT_X));
        var ftLineY = by - FT_DIST;
        var rimR = Math.round(0.75 * S);
        var bbW = Math.round(3 * S);

        ctx.fillStyle = '#fafafa';
        ctx.fillRect(0, 0, W, H);

        var zones = data.zones || {};
        var league = data.league_avg || {};

        function getZoneColor(zoneKey) {
            var tz = zones[zoneKey];
            var lz = league[zoneKey];
            if (!tz || !lz) return 'rgba(200,200,200,0.3)';
            var freqDiff = tz.freq - lz.freq;
            var intensity = Math.min(Math.abs(freqDiff) / 4, 1);
            var alpha = 0.25 + intensity * 0.55;
            if (freqDiff >= 0) {
                var r = Math.round(215 * intensity + 240 * (1 - intensity));
                var g = Math.round(38 * intensity + 200 * (1 - intensity));
                var b = Math.round(56 * intensity + 200 * (1 - intensity));
                return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha.toFixed(2) + ')';
            } else {
                var r2 = Math.round(30 * intensity + 200 * (1 - intensity));
                var g2 = Math.round(58 * intensity + 200 * (1 - intensity));
                var b2 = Math.round(138 * intensity + 220 * (1 - intensity));
                return 'rgba(' + r2 + ',' + g2 + ',' + b2 + ',' + alpha.toFixed(2) + ')';
            }
        }

        function drawZoneLabel(cx, cy, zoneKey) {
            var tz = zones[zoneKey];
            if (!tz || tz.fga === 0) return;
            var lz = league[zoneKey];
            ctx.fillStyle = '#111';
            ctx.font = 'bold 13px system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(tz.fg_pct + '%', cx, cy - 8);
            ctx.font = '10px system-ui, sans-serif';
            ctx.fillStyle = '#555';
            ctx.fillText(tz.fga + ' FGA', cx, cy + 8);
            if (lz) {
                var diff = tz.freq - lz.freq;
                ctx.font = 'bold 9px system-ui, sans-serif';
                ctx.fillStyle = diff > 0.3 ? '#d72638' : (diff < -0.3 ? '#1e3a8a' : '#888');
                ctx.fillText((diff > 0 ? '+' : '') + diff.toFixed(1) + '% freq', cx, cy + 22);
            }
        }

        ctx.save();
        ctx.beginPath();
        ctx.rect(bx - COURT_HW, 0, COURT_HW * 2, baseY);
        ctx.clip();

        ctx.fillStyle = getZoneColor('Above Break 3');
        ctx.fillRect(bx - COURT_HW, 0, COURT_HW * 2, baseY);

        ctx.fillStyle = getZoneColor('Corner 3');
        ctx.beginPath();
        ctx.rect(bx - COURT_HW, CORNER_TOP_Y, COURT_HW - THREE_STRAIGHT_X, baseY - CORNER_TOP_Y);
        ctx.fill();
        ctx.beginPath();
        ctx.rect(bx + THREE_STRAIGHT_X, CORNER_TOP_Y, COURT_HW - THREE_STRAIGHT_X, baseY - CORNER_TOP_Y);
        ctx.fill();

        ctx.fillStyle = getZoneColor('Mid-Range');
        ctx.beginPath();
        ctx.moveTo(bx - THREE_STRAIGHT_X, baseY);
        ctx.lineTo(bx - THREE_STRAIGHT_X, CORNER_TOP_Y);
        ctx.arc(bx, by, THREE_R, Math.PI + THREE_ANG, Math.PI * 2 - THREE_ANG);
        ctx.lineTo(bx + THREE_STRAIGHT_X, baseY);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = getZoneColor('Paint (Non-RA)');
        ctx.beginPath();
        ctx.rect(bx - LANE_HW, ftLineY, LANE_HW * 2, baseY - ftLineY);
        ctx.fill();

        ctx.fillStyle = getZoneColor('Restricted Area');
        ctx.beginPath();
        ctx.arc(bx, by, RA_R, Math.PI, Math.PI * 2);
        ctx.closePath();
        ctx.fill();

        ctx.restore();

        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1.5;

        ctx.beginPath();
        ctx.moveTo(bx - COURT_HW, baseY);
        ctx.lineTo(bx + COURT_HW, baseY);
        ctx.stroke();

        ctx.beginPath();
        ctx.rect(bx - COURT_HW, baseY - Math.round(47 * S), COURT_HW * 2, Math.round(47 * S));
        ctx.stroke();

        ctx.beginPath();
        ctx.rect(bx - LANE_HW, ftLineY, LANE_HW * 2, baseY - ftLineY);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(bx, ftLineY, FT_R, Math.PI, Math.PI * 2);
        ctx.stroke();

        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(bx, ftLineY, FT_R, 0, Math.PI);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.beginPath();
        ctx.arc(bx, by, RA_R, Math.PI, Math.PI * 2);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(bx - THREE_STRAIGHT_X, baseY);
        ctx.lineTo(bx - THREE_STRAIGHT_X, CORNER_TOP_Y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(bx + THREE_STRAIGHT_X, baseY);
        ctx.lineTo(bx + THREE_STRAIGHT_X, CORNER_TOP_Y);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(bx, by, THREE_R, Math.PI + THREE_ANG, Math.PI * 2 - THREE_ANG);
        ctx.stroke();

        ctx.strokeStyle = '#333';
        ctx.beginPath();
        ctx.arc(bx, by, rimR, 0, Math.PI * 2);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(bx - bbW, baseY - Math.round(4 * S));
        ctx.lineTo(bx + bbW, baseY - Math.round(4 * S));
        ctx.stroke();

        var mcY = baseY - Math.round(47 * S);
        ctx.beginPath();
        ctx.arc(bx, mcY, Math.round(2 * S), 0, Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(bx, mcY, Math.round(6 * S), 0, Math.PI);
        ctx.stroke();

        drawZoneLabel(bx, by - RA_R / 2 - 5, 'Restricted Area');
        drawZoneLabel(bx, by - RA_R - (FT_DIST - RA_R) / 2, 'Paint (Non-RA)');
        drawZoneLabel(bx - LANE_HW - 55, by - FT_DIST / 2, 'Mid-Range');
        drawZoneLabel(bx, by - THREE_R - 30, 'Above Break 3');
        drawZoneLabel(bx - THREE_STRAIGHT_X - (COURT_HW - THREE_STRAIGHT_X) / 2, by + 10, 'Corner 3');
        drawZoneLabel(bx + THREE_STRAIGHT_X + (COURT_HW - THREE_STRAIGHT_X) / 2, by + 10, 'Corner 3');
    }

    function renderDefShotStats(data) {
        var container = document.getElementById('def-shot-zone-stats');
        var zones = data.zones || {};
        var league = data.league_avg || {};

        var zoneOrder = ['Restricted Area', 'Paint (Non-RA)', 'Mid-Range', 'Above Break 3', 'Corner 3'];

        var html = '<table><thead><tr><th>Zone</th><th>Opp FGA</th><th>Opp FGM</th><th>Opp FG%</th><th>Lg FG%</th><th>Freq%</th><th>Lg Freq%</th><th>vs Avg</th></tr></thead><tbody>';
        for (var i = 0; i < zoneOrder.length; i++) {
            var z = zoneOrder[i];
            var tz = zones[z];
            if (!tz) continue;
            var lz = league[z] || {};
            var freqDiff = tz.freq - (lz.freq || 0);
            var fgDiff = tz.fg_pct - (lz.fg_pct || 0);
            var freqClass = freqDiff > 0.3 ? 'freq-diff-pos' : (freqDiff < -0.3 ? 'freq-diff-neg' : '');
            var fgClass = fgDiff > 0.5 ? 'fg-diff-pos' : (fgDiff < -0.5 ? 'fg-diff-neg' : '');
            html += '<tr>';
            html += '<td style="text-align:left;font-weight:600;">' + z + '</td>';
            html += '<td>' + tz.fga.toLocaleString() + '</td>';
            html += '<td>' + tz.fgm.toLocaleString() + '</td>';
            html += '<td class="' + fgClass + '">' + tz.fg_pct + '%</td>';
            html += '<td>' + (lz.fg_pct || 0) + '%</td>';
            html += '<td>' + tz.freq + '%</td>';
            html += '<td>' + (lz.freq || 0) + '%</td>';
            html += '<td class="' + freqClass + '">' + (freqDiff > 0 ? '+' : '') + freqDiff.toFixed(1) + '%</td>';
            html += '</tr>';
        }
        html += '</tbody></table>';
        container.innerHTML = html;
    }
})();

(function() {
    var table = document.getElementById('explorer-table');
    if (!table) return;

    var searchInput = document.getElementById('explorer-search');
    var posFilter = document.getElementById('explorer-pos-filter');
    var teamFilter = document.getElementById('explorer-team-filter');
    var statusFilter = document.getElementById('explorer-status-filter');

    var teams = new Set();
    var rows = Array.from(table.querySelectorAll('tbody tr'));
    rows.forEach(function(r) {
        var t = r.getAttribute('data-team');
        if (t) teams.add(t);
    });
    Array.from(teams).sort().forEach(function(t) {
        var opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        teamFilter.appendChild(opt);
    });

    function applyFilters() {
        var search = searchInput.value.toLowerCase().trim();
        var pos = posFilter.value;
        var team = teamFilter.value;
        var status = statusFilter.value;

        rows.forEach(function(row) {
            var name = (row.getAttribute('data-name') || '').toLowerCase();
            var rPos = row.getAttribute('data-pos') || '';
            var rTeam = row.getAttribute('data-team') || '';
            var rInjury = row.getAttribute('data-injury') || '';

            var show = true;
            if (search && name.indexOf(search) === -1) show = false;
            if (pos && rPos.indexOf(pos) === -1) show = false;
            if (team && rTeam !== team) show = false;
            if (status === 'healthy') {
                if (rInjury && rInjury !== '') show = false;
            } else if (status && rInjury !== status) {
                show = false;
            }
            row.style.display = show ? '' : 'none';
        });
    }

    searchInput.addEventListener('input', applyFilters);
    posFilter.addEventListener('change', applyFilters);
    teamFilter.addEventListener('change', applyFilters);
    statusFilter.addEventListener('change', applyFilters);

    var headers = table.querySelectorAll('thead th[data-sortable]');
    var sortCol = -1, sortAsc = true;
    headers.forEach(function(th, idx) {
        th.style.cursor = 'pointer';
        th.addEventListener('click', function() {
            if (sortCol === idx) { sortAsc = !sortAsc; } else { sortCol = idx; sortAsc = true; }
            headers.forEach(function(h) { h.classList.remove('sort-asc', 'sort-desc'); });
            th.classList.add(sortAsc ? 'sort-asc' : 'sort-desc');
            var type = th.getAttribute('data-sortable');
            rows.sort(function(a, b) {
                var aVal = a.children[idx].textContent.trim();
                var bVal = b.children[idx].textContent.trim();
                if (type === 'number') {
                    aVal = parseFloat(aVal.replace(/[^0-9.\-]/g, '')) || 0;
                    bVal = parseFloat(bVal.replace(/[^0-9.\-]/g, '')) || 0;
                    return sortAsc ? aVal - bVal : bVal - aVal;
                }
                return sortAsc ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            });
            var tbody = table.querySelector('tbody');
            rows.forEach(function(r) { tbody.appendChild(r); });
        });
    });
})();

function openExplorerShotChart(playerName, evt) {
    if (evt) evt.stopPropagation();
    var modal = document.getElementById('explorer-shot-chart-modal');
    var loading = document.getElementById('esc-loading');
    var canvas = document.getElementById('esc-canvas');
    var body = document.querySelector('.esc-body');
    modal.style.display = 'flex';
    body.style.display = 'none';
    loading.style.display = 'block';
    document.getElementById('esc-player-name').textContent = playerName;
    document.getElementById('esc-archetype-badge').textContent = '';
    document.getElementById('esc-total-fga').textContent = '';
    document.getElementById('esc-zone-stats').innerHTML = '';

    fetch('/api/player-shot-chart/' + encodeURIComponent(playerName))
        .then(function(r) { return r.json(); })
        .then(function(data) {
            loading.style.display = 'none';
            if (data.error || !data.zones || Object.keys(data.zones).length === 0 || data.total_fga === 0) {
                body.style.display = 'block';
                document.getElementById('esc-zone-stats').innerHTML = '<div style="text-align:center;padding:30px;color:#888;">' + (data.error || 'No shot data available') + '</div>';
                return;
            }
            body.style.display = 'block';
            if (data.archetype) document.getElementById('esc-archetype-badge').textContent = data.archetype;
            document.getElementById('esc-total-fga').textContent = data.total_fga + ' FGA';
            renderExplorerShotChart(canvas, data);
            renderExplorerZoneStats(data);
        })
        .catch(function() {
            loading.style.display = 'none';
            body.style.display = 'block';
            document.getElementById('esc-zone-stats').innerHTML = '<div style="text-align:center;padding:30px;color:#888;">Failed to load shot chart</div>';
        });
}

function closeExplorerShotChart() {
    document.getElementById('explorer-shot-chart-modal').style.display = 'none';
}

document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        var escModal = document.getElementById('explorer-shot-chart-modal');
        if (escModal && escModal.style.display !== 'none') closeExplorerShotChart();
    }
});

function renderExplorerShotChart(canvas, data) {
    var W = 500, H = 470;
    var dpr = window.devicePixelRatio || 1;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    var ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, W, H);

    var S = 9;
    var bx = 250;
    var baseY = 452;
    var by = baseY - Math.round(5.25 * S);
    var RA_R = Math.round(4 * S);
    var LANE_HW = Math.round(8 * S);
    var FT_DIST = Math.round(13.75 * S);
    var FT_R = Math.round(6 * S);
    var THREE_R = Math.round(23.75 * S);
    var THREE_STRAIGHT_X = Math.round(22 * S);
    var COURT_HW = Math.round(25 * S);
    var THREE_ANG = Math.acos(THREE_STRAIGHT_X / THREE_R);
    var CORNER_TOP_Y = by - Math.round(Math.sqrt(THREE_R * THREE_R - THREE_STRAIGHT_X * THREE_STRAIGHT_X));
    var ftLineY = by - FT_DIST;
    var rimR = Math.round(0.75 * S);
    var bbW = Math.round(3 * S);
    var zones = data.zones || {};
    var league = data.league_avg || {};

    ctx.fillStyle = '#fafafa';
    ctx.fillRect(0, 0, W, H);

    function getZoneColor(zoneKey) {
        var pz = zones[zoneKey];
        var lz = league[zoneKey];
        if (!pz || !lz) return 'rgba(200,200,200,0.3)';
        var freqDiff = pz.freq - lz.freq;
        var intensity = Math.min(Math.abs(freqDiff) / 12, 1);
        var alpha = 0.2 + intensity * 0.5;
        if (freqDiff >= 0) {
            return 'rgba(' + Math.round(215*intensity+240*(1-intensity)) + ',' + Math.round(38*intensity+200*(1-intensity)) + ',' + Math.round(56*intensity+200*(1-intensity)) + ',' + alpha.toFixed(2) + ')';
        } else {
            return 'rgba(' + Math.round(30*intensity+200*(1-intensity)) + ',' + Math.round(58*intensity+200*(1-intensity)) + ',' + Math.round(138*intensity+220*(1-intensity)) + ',' + alpha.toFixed(2) + ')';
        }
    }

    function drawZoneLabel(cx, cy, zoneKey) {
        var pz = zones[zoneKey];
        if (!pz || pz.fga === 0) return;
        ctx.fillStyle = '#111';
        ctx.font = 'bold 13px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(pz.fg_pct + '%', cx, cy - 8);
        ctx.font = '10px system-ui, sans-serif';
        ctx.fillStyle = '#555';
        ctx.fillText(pz.fga + ' FGA', cx, cy + 8);
        var lz = league[zoneKey];
        if (lz) {
            var diff = pz.freq - lz.freq;
            ctx.font = 'bold 9px system-ui, sans-serif';
            ctx.fillStyle = diff > 0.5 ? '#d72638' : (diff < -0.5 ? '#1e3a8a' : '#888');
            ctx.fillText((diff > 0 ? '+' : '') + diff.toFixed(1) + '% freq', cx, cy + 22);
        }
    }

    ctx.save();
    ctx.beginPath();
    ctx.rect(bx - COURT_HW, 0, COURT_HW * 2, baseY);
    ctx.clip();

    ctx.fillStyle = getZoneColor('Above Break 3');
    ctx.fillRect(bx - COURT_HW, 0, COURT_HW * 2, baseY);
    ctx.fillStyle = getZoneColor('Corner 3');
    ctx.beginPath();
    ctx.rect(bx - COURT_HW, CORNER_TOP_Y, COURT_HW - THREE_STRAIGHT_X, baseY - CORNER_TOP_Y);
    ctx.fill();
    ctx.beginPath();
    ctx.rect(bx + THREE_STRAIGHT_X, CORNER_TOP_Y, COURT_HW - THREE_STRAIGHT_X, baseY - CORNER_TOP_Y);
    ctx.fill();
    ctx.fillStyle = getZoneColor('Mid-Range');
    ctx.beginPath();
    ctx.moveTo(bx - THREE_STRAIGHT_X, baseY);
    ctx.lineTo(bx - THREE_STRAIGHT_X, CORNER_TOP_Y);
    ctx.arc(bx, by, THREE_R, Math.PI + THREE_ANG, Math.PI * 2 - THREE_ANG);
    ctx.lineTo(bx + THREE_STRAIGHT_X, baseY);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = getZoneColor('Paint (Non-RA)');
    ctx.beginPath();
    ctx.rect(bx - LANE_HW, ftLineY, LANE_HW * 2, baseY - ftLineY);
    ctx.fill();
    ctx.fillStyle = getZoneColor('Restricted Area');
    ctx.beginPath();
    ctx.arc(bx, by, RA_R, Math.PI, Math.PI * 2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(bx - COURT_HW, baseY); ctx.lineTo(bx + COURT_HW, baseY); ctx.stroke();
    ctx.beginPath(); ctx.rect(bx - COURT_HW, baseY - Math.round(47 * S), COURT_HW * 2, Math.round(47 * S)); ctx.stroke();
    ctx.beginPath(); ctx.rect(bx - LANE_HW, ftLineY, LANE_HW * 2, baseY - ftLineY); ctx.stroke();
    ctx.beginPath(); ctx.arc(bx, ftLineY, FT_R, Math.PI, Math.PI * 2); ctx.stroke();
    ctx.setLineDash([5, 5]);
    ctx.beginPath(); ctx.arc(bx, ftLineY, FT_R, 0, Math.PI); ctx.stroke();
    ctx.setLineDash([]);
    ctx.beginPath(); ctx.arc(bx, by, RA_R, Math.PI, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx - THREE_STRAIGHT_X, baseY); ctx.lineTo(bx - THREE_STRAIGHT_X, CORNER_TOP_Y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx + THREE_STRAIGHT_X, baseY); ctx.lineTo(bx + THREE_STRAIGHT_X, CORNER_TOP_Y); ctx.stroke();
    ctx.beginPath(); ctx.arc(bx, by, THREE_R, Math.PI + THREE_ANG, Math.PI * 2 - THREE_ANG); ctx.stroke();
    ctx.strokeStyle = '#333';
    ctx.beginPath(); ctx.arc(bx, by, rimR, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx - bbW, baseY - Math.round(4 * S)); ctx.lineTo(bx + bbW, baseY - Math.round(4 * S)); ctx.stroke();
    var mcY = baseY - Math.round(47 * S);
    ctx.beginPath(); ctx.arc(bx, mcY, Math.round(2 * S), 0, Math.PI); ctx.stroke();
    ctx.beginPath(); ctx.arc(bx, mcY, Math.round(6 * S), 0, Math.PI); ctx.stroke();

    drawZoneLabel(bx, by - RA_R / 2 - 5, 'Restricted Area');
    drawZoneLabel(bx, by - RA_R - (FT_DIST - RA_R) / 2, 'Paint (Non-RA)');
    drawZoneLabel(bx - LANE_HW - 55, by - FT_DIST / 2, 'Mid-Range');
    drawZoneLabel(bx, by - THREE_R - 30, 'Above Break 3');
    drawZoneLabel(bx - THREE_STRAIGHT_X - (COURT_HW - THREE_STRAIGHT_X) / 2, by + 10, 'Corner 3');
    drawZoneLabel(bx + THREE_STRAIGHT_X + (COURT_HW - THREE_STRAIGHT_X) / 2, by + 10, 'Corner 3');
}

function renderExplorerZoneStats(data) {
    var container = document.getElementById('esc-zone-stats');
    var zones = data.zones || {};
    var league = data.league_avg || {};
    var zoneOrder = ['Restricted Area', 'Paint (Non-RA)', 'Mid-Range', 'Above Break 3', 'Corner 3'];
    var html = '<table><thead><tr><th>Zone</th><th>FGA</th><th>FGM</th><th>FG%</th><th>Freq%</th><th>vs Avg</th></tr></thead><tbody>';
    for (var i = 0; i < zoneOrder.length; i++) {
        var z = zoneOrder[i];
        var pz = zones[z];
        if (!pz) continue;
        var lz = league[z] || {};
        var diff = pz.freq - (lz.freq || 0);
        var diffClass = diff > 0.5 ? 'freq-diff-pos' : (diff < -0.5 ? 'freq-diff-neg' : '');
        html += '<tr><td>' + z + '</td><td>' + pz.fga + '</td><td>' + pz.fgm + '</td><td>' + pz.fg_pct + '%</td><td>' + pz.freq + '%</td><td class="' + diffClass + '">' + (diff > 0 ? '+' : '') + diff.toFixed(1) + '%</td></tr>';
    }
    html += '</tbody></table>';
    container.innerHTML = html;
}

</script>
{% endblock %}
