{% extends "base.html" %}

{% block title %}Chart Gallery - PIRTDICA{% endblock %}

{% block content %}
<div class="trends-page">
    <div class="trends-header">
        <div>
            <h1 class="page-title">CHART GALLERY</h1>
            <p class="page-subtitle">Data-driven analysis for today's slate</p>
        </div>
        <form action="/trends/refresh" method="post" class="refresh-form">
            <button type="submit" class="btn btn-secondary refresh-btn">
                Refresh Data
            </button>
        </form>
    </div>
    
    <div class="trends-section">
        <h2>Usage to Fantasy Points</h2>
        <p class="chart-description">Usage rate vs fantasy points. Bigger bubbles = better value (FP per $1K). Top-right = high-usage stars.</p>
        <div class="chart-container">
            <img src="/static/images/value_chart.png?v={{ cache_bust }}" alt="Usage to Fantasy Points" class="trend-chart">
        </div>
    </div>
    
    <div class="trends-section">
        <h2>Risk-Reward Frontier</h2>
        <p class="chart-description">Bottom-right = cash plays, top-left = GPP darts, top-right = slate breakers.</p>
        <div class="chart-container">
            <img src="/static/images/upside_chart.png?v={{ cache_bust }}" alt="Risk-Reward Frontier" class="trend-chart">
        </div>
    </div>
    
    <div class="trends-section">
        <h2>Referee Foul Tendencies</h2>
        <p class="chart-description">Tonight's crews plotted by foul volume (X) and home/away bias (Y). ▲ = home-favored, ▼ = road-favored.</p>
        <div class="chart-container">
            {% if ref_chart_exists %}
            <img src="/static/images/ref_foul_chart.png?v={{ cache_bust }}" alt="Referee Foul Chart" class="trend-chart">
            {% else %}
            <div style="text-align:center; padding:40px 20px; color:#888; font-size:1.1rem;">
                Referee assignments for tonight's games haven't been posted yet. Check back closer to tip-off.
            </div>
            {% endif %}
        </div>
    </div>
    
    <div class="trends-section">
        <h2>Defense vs Position Matchups</h2>
        <p class="chart-description">Green = soft matchup (target). Red = tough matchup (avoid).</p>
        <div class="chart-container">
            <img src="/static/images/dvp_heatmap.png?v={{ cache_bust }}" alt="DVP Heatmap" class="trend-chart dvp-heatmap">
        </div>
    </div>
    
    <div class="trends-section">
        <h2>Player Archetype Clusters</h2>
        <p class="chart-description">K-Means clustering groups players by how they actually play. Each dot is a player, positioned by PCA of 12 statistical features. Hover for details.</p>
        <div class="cluster-chart-wrapper">
            <canvas id="cluster-chart"></canvas>
        </div>
        <div id="cluster-legend" class="cluster-legend"></div>
    </div>
    
    {% if top_value %}
    <div class="trends-section">
        <h2>Top Value Plays</h2>
        <p class="chart-description">Players outperforming their salary tier. Value vs Tier shows how much better than peers at similar price.</p>
        <div class="value-table">
            <table>
                <thead>
                    <tr>
                        <th data-sortable="string">Player</th>
                        <th data-sortable="string">Team</th>
                        <th data-sortable="number">Salary</th>
                        <th data-sortable="number">Proj FP</th>
                        <th data-sortable="number">Floor</th>
                        <th data-sortable="number">Ceiling</th>
                        <th data-sortable="number">FP/$1k</th>
                        <th data-sortable="number">vs Tier</th>
                        <th data-sortable="string">Tier</th>
                        <th data-sortable="string">Archetype</th>
                    </tr>
                </thead>
                <tbody>
                    {% for player in top_value %}
                    <tr>
                        <td>{{ player.player_name }}</td>
                        <td>{{ player.team }}</td>
                        <td>${{ "{:,}".format(player.salary|int) }}</td>
                        <td>{{ "%.1f"|format(player.proj_fp) }}</td>
                        <td>{{ "%.1f"|format(player.get('floor', 0)) }}</td>
                        <td>{{ "%.1f"|format(player.get('ceiling', 0)) }}</td>
                        <td class="value-cell">{{ "%.2f"|format(player.get('value_ratio', player.get('value', 0))) }}</td>
                        <td class="{% if player.get('value_vs_tier', 0) > 0 %}positive-value{% else %}negative-value{% endif %}">{{ "%+.1f"|format((player.get('value_vs_tier', 0) * 100)) }}%</td>
                        <td>{{ player.get('tier', player.get('salary_tier', '')) }}</td>
                        <td><span class="archetype-badge archetype-{{ player.get('archetype', 'Unknown')|lower|replace(' ', '-')|replace('(', '')|replace(')', '') }}">{{ player.get('archetype', '') }}</span></td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    {% endif %}
    
    {% if targeted %}
    <div class="trends-section">
        <h2>Targeted Stat Plays</h2>
        <p class="chart-description">Players facing teams that give up extra fantasy points in specific stats. Sorted by FP impact.</p>
        <div class="targeted-table">
            <table>
                <thead>
                    <tr>
                        <th>Player</th>
                        <th>Pos</th>
                        <th>vs</th>
                        <th>Stat</th>
                        <th>Avg</th>
                        <th>+FP</th>
                        <th>Matchup Note</th>
                    </tr>
                </thead>
                <tbody>
                    {% for play in targeted %}
                    <tr>
                        <td>{{ play.player_name }}</td>
                        <td>{{ play.position }}</td>
                        <td>{{ play.opponent }}</td>
                        <td>{{ play.stat }}</td>
                        <td>{{ play.player_avg }}</td>
                        <td class="edge-cell">+{{ play.extra_fp }}</td>
                        <td class="matchup-note">{{ play.recommendation }}</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    {% endif %}
    
    {% if props %}
    <div class="trends-section">
        <h2>Prop Recommendations</h2>
        <p class="chart-description">Our projections vs FanDuel book lines. Sorted by largest edge where our model disagrees with the market.</p>
        <div class="table-controls">
            <input type="text" class="table-search" data-table="props-table" placeholder="Search player...">
        </div>
        <div class="props-table">
            <table id="props-table">
                <thead>
                    <tr>
                        <th data-sortable="text">Player</th>
                        <th data-sortable="text">vs</th>
                        <th data-sortable="text">Stat</th>
                        <th data-sortable="number">Avg</th>
                        <th data-sortable="number">Proj</th>
                        <th data-sortable="number">Line</th>
                        <th data-sortable="number">Edge%</th>
                        <th data-sortable="text">Call</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody>
                    {% for prop in props %}
                    <tr>
                        <td>{{ prop.player }}</td>
                        <td>{{ prop.opponent }}</td>
                        <td>{{ prop.stat }}</td>
                        <td>{{ prop.player_avg }}</td>
                        <td>{{ prop.adjusted_avg }}</td>
                        <td>{{ prop.book_line if prop.book_line is not none and prop.book_line == prop.book_line else '—' }}</td>
                        <td class="{% if prop.vs_book_edge is not none and prop.vs_book_edge == prop.vs_book_edge %}{% if prop.vs_book_edge > 15 %}fp-positive{% elif prop.vs_book_edge < -15 %}fp-negative{% else %}fp-neutral{% endif %}{% endif %}">{{ '%+.1f'|format(prop.vs_book_edge) if prop.vs_book_edge is not none and prop.vs_book_edge == prop.vs_book_edge else '—' }}</td>
                        <td class="{% if prop.recommendation == 'OVER' %}over-cell{% else %}under-cell{% endif %}">{{ prop.recommendation }}</td>
                        <td class="trend-btn-cell"><button class="trend-analysis-btn" data-player="{{ prop.player }}" data-stat="{{ prop.stat }}" data-line="{{ prop.book_line if prop.book_line is not none and prop.book_line == prop.book_line else '' }}" data-call="{{ prop.recommendation }}" title="View trend">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
                        </button></td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    {% endif %}
</div>

<div id="trend-modal" class="trend-modal-overlay" style="display:none;">
    <div class="trend-modal">
        <div class="trend-modal-header">
            <h3 id="trend-modal-title"></h3>
            <button class="trend-modal-close" onclick="closeTrendModal()">&times;</button>
        </div>
        <div class="trend-modal-body">
            <canvas id="trend-chart" height="260"></canvas>
        </div>
        <div class="trend-modal-legend">
            <span class="legend-item"><span class="legend-line legend-blue"></span> FanDuel Line</span>
            <span class="legend-item"><span class="legend-line legend-grey"></span> Player Average</span>
        </div>
        <div class="trend-modal-footer">
            <span id="trend-modal-avg"></span>
            <span id="trend-modal-call"></span>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
const ARCHETYPE_COLORS = {
    'Combo Guard': '#1a1a2e',
    'Combo Guard (Elite)': '#16213e',
    'Playmaker': '#0f3460',
    'Scoring Wing': '#e94560',
    '3-and-D Wing': '#533483',
    '3-and-D Wing (Role)': '#7b2d8e',
    'Point Forward': '#2d6a4f',
    'Stretch Big': '#d4a373',
    'Traditional Big': '#6c757d',
    'Versatile Big': '#495057',
    'Athletic Wing': '#264653',
    'Point Center': '#e76f51',
};

let clusterChart = null;

async function loadClusterChart() {
    try {
        const res = await fetch('/api/archetype-clusters');
        const data = await res.json();
        if (!data.players || data.players.length === 0) {
            document.querySelector('.cluster-chart-wrapper').innerHTML = '<div style="text-align:center;padding:40px 20px;color:#888;font-size:1.1rem;">Archetype clustering data not yet available. Run the daily update to generate clusters.</div>';
            return;
        }

        const grouped = {};
        data.players.forEach(p => {
            if (!grouped[p.archetype]) grouped[p.archetype] = [];
            grouped[p.archetype].push(p);
        });

        const isMobile = window.innerWidth < 768;
        const ptRadius = isMobile ? 3.5 : 6;
        const ptHover = isMobile ? 6 : 9;
        const borderW = isMobile ? 1 : 1.5;

        const datasets = Object.entries(grouped).map(([arch, players]) => ({
            label: arch,
            data: players.map(p => ({ x: p.x, y: p.y, name: p.name, team: p.team, pts: p.pts, reb: p.reb, ast: p.ast, usg: p.usg })),
            backgroundColor: (ARCHETYPE_COLORS[arch] || '#888') + 'cc',
            borderColor: ARCHETYPE_COLORS[arch] || '#888',
            borderWidth: borderW,
            pointRadius: ptRadius,
            pointHoverRadius: ptHover,
        }));

        const ctx = document.getElementById('cluster-chart').getContext('2d');
        if (clusterChart) clusterChart.destroy();

        clusterChart = new Chart(ctx, {
            type: 'scatter',
            data: { datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: isMobile ? { top: 4, right: 4, bottom: 4, left: 4 } : { top: 10, right: 10, bottom: 10, left: 10 }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const p = context.raw;
                                return [
                                    p.name + ' (' + p.team + ')',
                                    context.dataset.label,
                                    'PTS/100: ' + p.pts + '  REB/100: ' + p.reb,
                                    'AST/100: ' + p.ast + '  USG%: ' + p.usg
                                ];
                            }
                        },
                        backgroundColor: '#111',
                        titleFont: { family: 'Marvel', size: isMobile ? 11 : 13 },
                        bodyFont: { family: 'Marvel', size: isMobile ? 10 : 12 },
                        padding: isMobile ? 6 : 10,
                        cornerRadius: 6,
                    }
                },
                scales: {
                    x: {
                        title: { display: !isMobile, text: 'PC1 (' + data.variance_explained[0] + '% var)', font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' },
                        grid: { color: '#e5e7eb' },
                        ticks: { font: { family: 'Marvel', size: isMobile ? 9 : 12 }, maxTicksLimit: isMobile ? 5 : 10 }
                    },
                    y: {
                        title: { display: !isMobile, text: 'PC2 (' + data.variance_explained[1] + '% var)', font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' },
                        grid: { color: '#e5e7eb' },
                        ticks: { font: { family: 'Marvel', size: isMobile ? 9 : 12 }, maxTicksLimit: isMobile ? 5 : 10 }
                    }
                }
            }
        });

        const legendEl = document.getElementById('cluster-legend');
        legendEl.innerHTML = data.archetypes.map(arch => {
            const color = ARCHETYPE_COLORS[arch] || '#888';
            const count = (grouped[arch] || []).length;
            return '<span class="cluster-legend-item" data-arch="' + arch + '">' +
                   '<span class="cluster-legend-dot" style="background:' + color + '"></span>' +
                   arch + ' <span class="cluster-legend-count">(' + count + ')</span></span>';
        }).join('');

        legendEl.querySelectorAll('.cluster-legend-item').forEach(item => {
            item.addEventListener('click', function() {
                const arch = this.dataset.arch;
                const ds = clusterChart.data.datasets.find(d => d.label === arch);
                if (ds) {
                    const idx = clusterChart.data.datasets.indexOf(ds);
                    const meta = clusterChart.getDatasetMeta(idx);
                    meta.hidden = !meta.hidden;
                    this.classList.toggle('cluster-legend-dimmed');
                    clusterChart.update();
                }
            });
        });

    } catch(e) {
        console.error('Cluster chart error:', e);
    }
}

loadClusterChart();

let trendChart = null;

document.querySelectorAll('.trend-analysis-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const player = this.dataset.player;
        const stat = this.dataset.stat;
        const line = this.dataset.line ? parseFloat(this.dataset.line) : null;
        const call = this.dataset.call;
        openTrendModal(player, stat, line, call);
    });
});

async function openTrendModal(player, stat, line, call) {
    const modal = document.getElementById('trend-modal');
    const title = document.getElementById('trend-modal-title');
    const avgEl = document.getElementById('trend-modal-avg');
    const callEl = document.getElementById('trend-modal-call');
    
    title.textContent = player + ' — ' + stat + ' (Last 10 Games)';
    avgEl.textContent = 'Loading...';
    callEl.textContent = '';
    modal.style.display = 'flex';

    try {
        const res = await fetch('/api/player-trend/' + encodeURIComponent(player) + '/' + encodeURIComponent(stat) + '?n=10');
        const data = await res.json();
        if (data.error && (!data.games || data.games.length === 0)) {
            avgEl.textContent = 'No game log data available.';
            return;
        }
        const labels = data.games.map(g => {
            const m = g.matchup || '';
            const parts = m.split(' ');
            return parts[parts.length - 1] || g.date;
        });
        const values = data.games.map(g => g.value);
        const avg = data.avg;

        avgEl.textContent = '10-Game Avg: ' + avg;
        if (call) {
            callEl.textContent = call;
            callEl.className = call === 'OVER' ? 'trend-call-over' : 'trend-call-under';
        }

        const barColors = values.map(v => {
            if (line !== null) {
                return v >= line ? '#111827' : '#d1d5db';
            }
            return v >= avg ? '#111827' : '#d1d5db';
        });

        const ctx = document.getElementById('trend-chart').getContext('2d');
        if (trendChart) trendChart.destroy();

        const datasets = [{
            label: stat,
            data: values,
            backgroundColor: barColors,
            borderRadius: 4,
            barPercentage: 0.7
        }];

        trendChart = new Chart(ctx, {
            type: 'bar',
            data: { labels, datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: { beginAtZero: true, grid: { color: '#e5e7eb' }, ticks: { font: { family: 'Marvel' } }, title: { display: true, text: stat, font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' } },
                    x: { grid: { display: false }, ticks: { font: { family: 'Marvel', size: 11 } }, title: { display: true, text: 'Game', font: { family: 'Marvel', size: 13, weight: 'bold' }, color: '#374151' } }
                }
            },
            plugins: [{
                id: 'customLines',
                afterDraw(chart) {
                    const ctx = chart.ctx;
                    const yAxis = chart.scales.y;
                    const xAxis = chart.scales.x;
                    
                    if (line !== null) {
                        const yLine = yAxis.getPixelForValue(line);
                        ctx.save();
                        ctx.strokeStyle = '#2563eb';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([6, 4]);
                        ctx.beginPath();
                        ctx.moveTo(xAxis.left, yLine);
                        ctx.lineTo(xAxis.right, yLine);
                        ctx.stroke();
                        ctx.restore();
                    }
                    
                    const yAvg = yAxis.getPixelForValue(avg);
                    ctx.save();
                    ctx.strokeStyle = '#6b7280';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(xAxis.left, yAvg);
                    ctx.lineTo(xAxis.right, yAvg);
                    ctx.stroke();
                    ctx.restore();
                }
            }]
        });
    } catch(e) {
        avgEl.textContent = 'Error loading trend data.';
    }
}

function closeTrendModal() {
    document.getElementById('trend-modal').style.display = 'none';
    if (trendChart) { trendChart.destroy(); trendChart = null; }
}

document.getElementById('trend-modal').addEventListener('click', function(e) {
    if (e.target === this) closeTrendModal();
});
</script>
{% endblock %}
